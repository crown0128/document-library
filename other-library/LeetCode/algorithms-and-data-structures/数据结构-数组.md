数据结构 - 数组
===

> Create by **jsliang** on **2019-07-31 11:22:27**  
> Recently revised in **2019-08-15 13:58:25**

数组 - 最简单的内存数据结构

## <a name="chapter-one" id="chapter-one">一 目录</a>

**不折腾的前端，和咸鱼有什么区别**

| 目录 |
| --- | 
| [一 目录](#chapter-one) | 
| <a name="catalog-chapter-two" id="catalog-chapter-two"></a>[二 前言](#chapter-two) |
| &emsp;[2.1 为什么用数组？](#chapter-two-one) |
| &emsp;[2.2 如何创建和初始化数组？](#chapter-two-two) |
| &emsp;[2.3 如何访问数组？](#chapter-two-three) |
| &emsp;[2.4 二维、三维乃至多维数组以及如何访问？](#chapter-two-four) |
| &emsp;[2.5 来份案例热热身？](#chapter-two-five) |
| &emsp;[2.6 悬难疑惑？](#chapter-two-six) |
| <a name="catalog-chapter-three" id="catalog-chapter-three"></a>[三 数组的增删改查及其工作应用](#chapter-three) |
| &emsp;[3.1 数组的新增操作](#chapter-three-one) |
| &emsp;[3.2 数组的删除和修改操作](#chapter-three-two) |
| &emsp;&emsp;[3.2.1 删除和修改之 splice()](#chapter-three-two-one) |
| &emsp;&emsp;[3.2.2 删除和修改之 slice()](#chapter-three-two-two) |
| &emsp;&emsp;[3.2.3 删除和修改之 filter()](#chapter-three-two-three) |
| &emsp;[3.3 数组的查询操作](#chapter-three-three) |
| <a name="catalog-chapter-four" id="catalog-chapter-four"></a>[四 数组的常用知识点](#chapter-four) |
| <a name="catalog-chapter-five" id="catalog-chapter-five"></a>[五 总结](#chapter-five) |

## <a name="chapter-two" id="chapter-two">二 前言</a>

> [返回目录](#chapter-one)

如果小伙伴刚好看到这篇文章，想了解下 **算法与数据结构** 中，关于 **数组** 的知识。

那么，希望看到这篇文章的小伙伴拥有：

1. 基本的 JavaScript 知识。
2. 知道一点点的数组及其用法。

同时，希望看完这篇文章的小伙伴掌握：

1. 数组基本常识
2. 数组的增删改查
3. 数组的常用知识点

但是，**jsliang** 无法确定小伙伴是否真具备上面知识点（前置条件），所以前言会简略介绍下数组，希望能先小科普一下，方便后面共同探讨。

如果小伙伴已经清楚数组相关基础知识点，可以跳过【前言】部分；

如果小伙伴不清楚或者想回顾下热热身，可以往下慢慢看。

### <a name="chapter-two-one" id="chapter-two-one">2.1 为什么用数组？</a>

> [返回目录](#chapter-one)

假设你写代码，列出星期一到星期日锻炼的时间，你可能会写成：

```js
let Monday = 1,
  Tuesday = 2,
  Wednesday = 3,
  Thursday = 4,
  Friday = 5,
  Saturday = 6,
  Sunday = 7;
```

这仅仅是一周的数据。

如果要你统计一年的数据，那样也太麻烦了，毕竟命名 365 个字段，会让人极度不适。

于是有了数组：

```js
let exercise = [1, 2, 3, 4, 5, 6, 7];
```

这不就变得简便了么。

### <a name="chapter-two-two" id="chapter-two-two">2.2 如何创建和初始化数组？</a>

> [返回目录](#chapter-one)

```js
let a = [];

let b = new Array();
```

这样都是可行的。

如果你想初始化有长度的数组，或者数组一开始就有值：

```js
let a = [1, 2, 3]; // [1, 2, 3]

let b = new Array(3); // [undefined, undefined, undefined]

let c = new Array([1, 2, 3]); // [1, 2, 3]

let d = new Array(3).fill(1); // [1, 1, 1]

let e = new Array(3).fill([]); // [[], [], []]
```

当然，后面两个通过 `fill()` 创建的数组，推荐碰到 `fill()` 方法的时候再进一步了解。

> 变量 e 形成的数组会出问题的嗷~

### <a name="chapter-two-three" id="chapter-two-three">2.3 如何访问数组？</a>

> [返回目录](#chapter-one)

```js
let a = [1, 2, 3];
console.log(arr[0]); // 1
console.log(arr[1]); // 2
console.log(arr[2]); // 3
```

记住数组的下标是从 0 开始的。  

> 如果某个程序猿跟你表白说你是它心中第 0 位的人……你还是拒绝 “他” 吧，已经走火入魔没救了。

### <a name="chapter-two-four" id="chapter-two-four">2.4 二维、三维乃至多维数组以及如何访问？</a>

> [返回目录](#chapter-one)

我们平时使用的 `[1, 2, 3]` 这种形式，称为一维数组。

而如果数组中嵌套数组，每嵌套多一层，就加一个维度，例如：

> 二维数组

```js
let a = [[1, 2, 3], [4, 5]]; // 二维数组

// 访问二维数组
for (let i = 0; i < a.length; i++) {
  for (let j = 0; j < a[i].length; j++) {
    console.log(a[i][j]);
  }
}
// 1
// 2
// 3
// 4
// 5
```

> 三维数组

```js
let b = [[1, 2, [3, 4]], [5, 6]]; // 三维数组

// 访问三维数组
for (let i = 0; i < b.length; i++) {
  for (let j = 0; j < b[i].length; j++) {
    for (let k = 0; k < b[i][j].length; k++) {
      console.log(b[i][j][k]);
    }
  }
}
// 3
// 4
```

至于多维数组，小伙伴可以自行推算。

### <a name="chapter-two-five" id="chapter-two-five">2.5 来份案例热热身？</a>

> [返回目录](#chapter-one)

在这里，贴两份代码带大家热热身。

> 遍历斐波那契数列

```js
const fibonacciSequence = [1, 1, 2, 3, 5, 8, 13];

for (let i = 0; i < fibonacciSequence.length; i++) {
  console.log(fibonacciSequence[i]);
}

// 1 1 2 3 5 8 13
```

> 实现斐波那契数列

```js
const fibonacciSequence = [1, 1];

for (let i = 2; i < 20; i++) {
  fibonacciSequence[i] = fibonacciSequence[i - 1] + fibonacciSequence[i - 2];
}

console.log(fibonacciSequence);

// [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]
```

### <a name="chapter-two-six" id="chapter-two-six">2.6 悬难疑惑？</a>

> [返回目录](#chapter-one)

数组虽然是最简单的内存数据结构，但是有些坑还是需要注意的，以免深陷无法自拔，例如：传值和传址。

```js
// 传值
let str1 = '1';
str2 = str1;
str2 = '2';
console.log(str1); // 1
console.log(str2); // 2

// 传址
let arr1 = [1, 2, 3];
arr2 = arr1;
arr2[0] = 4;
console.log(arr1); // [4, 2, 3]
console.log(arr2); // [4, 2, 3]
```

问：**jsliang** 你怎么看传值和传址，能不能详细介绍下？

答：看下我那篇面试文章 [jsliang 的 2019 面试准备](https://github.com/LiangJunrong/document-library/blob/master/other-library/interview/personal-experience/2019-interview-preparation.md#chapter-five-five) 或者百度下相关知识点吧，毕竟咱主要目的不是讲这个知识点，在这里引出是为了让小伙伴们热热身。

> 如果小伙伴觉得非常有必要将热身写成详细清单，小伙伴记得私信我哈

> 更多的数组问题或者相关隐藏点，还是等我想起来或者小伙伴提到，我再进行补充吧。

## <a name="chapter-three" id="chapter-three">三 数组的增删改查及其工作应用</a>

> [返回目录](#chapter-one)

提起 **算法与数据结构**，很多前端小伙伴可能第一时间反应：“卧槽这有卵用”，“为啥面试都搞这个，进去后还不是写 if...else...”……

enm...还真有用。

**jsliang** 结合数组的增删改查及其工作中的使用场景，跟你聊聊数组的妙用。

### <a name="chapter-three-one" id="chapter-three-one">3.1 数组的新增操作</a>

> [返回目录](#chapter-one)

话不多说，关门，放、放代码：

```js
let arr = [1, 2, 3];

// 通过 push() 方法
arr.push(4); // [1, 2, 3, 4]

// 通过 length 属性
arr[arr.length] = 5; // [1, 2, 3, 4, 5]
```

数组新增元素的两种方式：

* 一种是通过 `push()` 方法，直接将元素添加到数组最后一位。
* 另一种是通过利用数组的 `length` 属性，该属性可以显示数组的长度，而 `arr[arr.length]` 即给其最大长度后面再加一个长度。

既然上面我们通过两种方式，往数组后面插入了新元素，那么有没有方法，往数组前面插入新元素呢？

有！

```js
let arr = [3, 4, 5];

// 通过 unshift 方法
arr.unshift(2); // [2, 3, 4, 5]

// 通过遍历数组
for (let i = arr.length; i >= 0; i--) {
  arr[i] = arr[i - 1];
}
arr[0] = 1;
// [1, 2, 3, 4, 5]
```

很好，通过这四种方式，我们就掌握了往数组头部和数组尾部新增元素。

**那么**，在工作中它们有何作用呢？

目前使用最多的是 `push()` 操作，通常用于给数组新增元素。

举例常见的场景：给 Table 新增一行数据。

|  | 数据内容 |
| --- | --- |
| 新增 | 第一行数据 - jsliang |
| 新增 | 第二行数据 - 梁渣渣 |

> **jsliang** 尝试自己画了个表格，太小了不好贴图，就使用 Markdown 演示下好了。

如上，我们点击【新增】按钮的时候，就可以直接往 Table 下面新增一行数据。

而如果是 `unshift()`，目前工作还未接触到，如果有碰到的小伙伴，欢迎贴出应用场景~

### <a name="chapter-three-two" id="chapter-three-two">3.2 数组的删除和修改操作</a>

> [返回目录](#chapter-one)

**首先**，**jsliang** 觉得删除和修改操作在一定程度上利用的数组 API 非常一致，所以贴在一起写了：

* splice()
* slice()
* filter()

在这里，我们介绍三种方法进行操作。

#### <a name="chapter-three-two-one" id="chapter-three-two-one">3.2.1 删除和修改之 splice()</a>

> [返回目录](#chapter-one)

对于前端来说，数组的 `splice()` 方法是个万金油，它能适用于新增、修改、删除这些场景。

那么，如何利用 `splice()` 进行新增、修改和删除呢？

我们先了解下 `splice()` 特性：

```js
var months = ['Jan', 'March', 'April', 'June'];

// 新增操作
months.splice(1, 0, 'Feb');
// ['Jan', 'Feb', 'March', 'April', 'June']

// 修改操作
months.splice(4, 1, 'May');
// ['Jan', 'Feb', 'March', 'April', 'May']

// 删除操作
months.splice(4, 1);
// ['Jan', 'Feb', 'March', 'April']
```

如上，`splice()` 的语法是：`array.splice(start, deleteCount, item1, item2, ...)`。

1. `start` 为数组的开始坐标
2. `deleteCount` 为需要从开始坐标起，删除的个数，可以为 0，代表不删除
3. `item` 为需要新增进去的元素。

那么，讲到这里，小伙伴们应该对 `splice()` 有深刻了解了。

下面我们讲讲 `splice()` 对于修改操作，在工作中的使用场景：

> 修改 Table 某行的数据

```js
let list = [
  { id: '1', name: 'jsliang' },
  { id: '2', name: '梁峻荣' },
  { id: '3', name: 'JavaScriptLiang' },
];

function addData(rowIndex) {
  list.splice(rowIndex, 0, {
    id: '4',
    name: '梁渣渣',
  });
}

addData(1);

console.log(list);
// [
//   { id: '1', name: 'jsliang' },
//   { id: '4', name: '梁渣渣' },
//   { id: '2', name: '梁峻荣' },
//   { id: '3', name: 'JavaScriptLiang' },
// ]
```

如上，我们希望将数据添加到指定位置（`addData(n)`），这时候我们就使用了 `splice()` 对其进行操作，从而修改了原数组。

#### <a name="chapter-three-two-two" id="chapter-three-two-two">3.2.2 删除和修改之 slice()</a>

> [返回目录](#chapter-one)

而作为和 `splice()` 一个字母之差的 `slice()`，又是何等的优秀呢？

**首先**，咱们科普下：

* splice()：所进行的操作会影响到原数组
* slice()：所进行的操作不会影响到原数组

什么意思呢？相信很多小伙伴在网上看数组相关攻略的时候，都会看到一堆的区分：**这个方法会影响到原数组，这个方法不会影响到原数组……等等**。

其实很容易理解：我想吃两块蛋糕，但是现在我只有一块蛋糕。如果我还惦记着自己的减肥，那么我可以将这款蛋糕切成两块，这样我就吃到两块蛋糕（影响到原数组）；如果我觉得吃了两块蛋糕不会肥，那我就去照着这块蛋糕的样子，再买一块（不影响原数组）。

当然，这里都说是修改咯，`slice()` 还是有丢丢影响到数组的：

```js
const str = 'jsliang';
str.slice(0, 2); // 'js'
str.slice(2); // 'liang'
```

对于 `slice()` 来说，它的参数为：`str.slice(beginSlice, endSlice)`。其中：

* `beginSlice`：从该索引（以 0 为基数）处开始提取原字符串中的字符。
* `endSlice`：结束位置（以 0 为基数），如果不传，默认到数组末尾。

> 注意，`splice()` 的第二个参数是影响到数组的个数，而 `slice()` 的第二个参数是结束的位置，所以 `slice()` 一般写法是：`slice(index, index + length)`，即需要修改的位置（index），及其影响的长度（length）。

很好，说完这一堆废话，咱们讲讲工作中的使用场景：

```js
let list = [
  { id: '1', name: 'jsliang' },
  { id: '2', name: '梁峻荣' },
];

function insertData(rowId) {
  list = [
    ...list.slice(0, list.findIndex(item => item.id === rowId) + 1),
    {
      id: '3',
      name: '',
    },
    ...list.slice(list.findIndex(item => item.id === rowId) + 1),
  ]
}

insertData('1');

console.log(list);
// [
//   { id: '1', name: 'jsliang' },
//   { id: '3', name: '' },
//   { id: '2', name: '梁峻荣' },
// ]
```

还记得在上面我们说过用 `slice()` 做修改操作，*也会影响到原数组* 吗？是的，在这份代码我们可以看出，我们根据之前的数组，组合成一个新的数组，让这个元素指向了新的数组地址。

当然，这个并不重要，我们讲讲它的使用场景：在需要修改 Table 某行的时候，我们将其唯一值（id）传递了过去，然后方法 `insertData` 根据传递的 id 找到那一行，对其进行了修改。

> 如果你感觉并非那么容易理解，你可以尝试下将 `rowId` 换成 `index`，这是个明智的选择。

#### <a name="chapter-three-two-three" id="chapter-three-two-three">3.2.3 删除和修改之 filter()</a>

> [返回目录](#chapter-one)

**首先**，**jsliang** 对于 `filter()` 这个方法也不是很常使用：

我有个朋友，网名就叫 `filter()`，每次使用它就跟使唤我朋友一样：“filter！我有事请你帮忙~”

但是，作为团队的一枚 **螺丝钉**，业务写得多了，你还是会接触到同事的代码的，所以还是有必要对其进行了解：

```js
function isBigEnough(element) {
  return element >= 10;
}
var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);
// [12, 130, 44]

// 如果你喜欢用 ES6 的箭头函数
const number = [12, 5, 8, 130, 44];
const filterNumber = number.filter(item => item >= 10);
// [12, 130, 44]
```

很好，讲到这里，我们就顺带科普下 `filter()` 这个方法了：

* **语法**：`arr.filter(callback)`

* `callback`：用来测试数组的每个元素的函数。返回 `true` 表示该元素通过测试，保留该元素，`false` 则不保留。它会返回由通过元素组成的数组，或者是一个空数组 []。它接受以下三个参数：
  * `element`：数组中当前正在处理的元素
  * `index`：正在处理的元素在数组中的索引。
  * `array`：调用了 `filter` 的数组本身。

所以一个比较完整的 `filter()` 可以这么写：

```js
const number = [12, 5, 8, 130, 44];
const filterNumber = number.filter((item, index, array) => {
  console.log(array);
  return item >= 10 && index > 3;
});
// 输出 5 次 [12, 5, 8, 130, 44]
// 最终 filterNumber 的值为 [44]
```

OK，介绍完毕，咱们看下应用场景：

```js
let list = [
  { id: '1', name: 'jsliang' },
  { id: '2', name: '梁峻荣' },
  { id: '3', name: 'JavaScriptLiang' },
];

function changeData(id, newObj) {
  list = [...list.filter(item => item.id !== id), newObj];
}

changeData('2', {
  id: '4',
  name: '梁渣渣',
});
[
  {id: "1", name: "jsliang"},
  {id: "3", name: "JavaScriptLiang"},
  {id: "4", name: "梁渣渣"},
]
```

这样，我们就将 `id` 为 2 的 `梁峻荣` 那行修改为 `id` 为 4 的 `梁渣渣`。

### <a name="chapter-three-three" id="chapter-three-three">3.3 数组的查询操作</a>

> [返回目录](#chapter-one)

上面讲完了新增、删除和修改，最后还是讲讲查询操作。

相比于上面的话题，查询的形式就多了。

例如说，我想知道数组中所有对象的 id：

```js
let list = [
  { id: '1', name: 'jsliang' },
  { id: '2', name: '梁峻荣' },
  { id: '3', name: 'JavaScriptLiang' },
];

const ids = list.map(item => item.id);
// ["1", "2", "3"]
```

无可厚非这也是一种查询，而且在工作中特实用，毕竟像 Ant Design 等，下拉框多选等情况，就需要将数据的 id 查找出来。

又或者说，我想知道 `JavaScript` 出现在哪个索引值下，它的 id 是多少：

```js
let list = [
  { id: '1', name: 'jsliang' },
  { id: '2', name: '梁峻荣' },
  { id: '3', name: 'JavaScriptLiang' },
];

const id1 = list[list.findIndex(item => item.name === 'JavaScriptLiang')].id;
// '3'

// 当然有更快速的
const id2 = list.find(item => item.name === 'JavaScriptLiang').id;
// '3'
```

当然，JavaScript 还有很多操作，可以查询数组中的数据。

当然，不管怎么说，**jsliang** 还是强烈推荐将这些方法记下来，然后在工作中不停尝试使用，这样你才会有所提升。

## <a name="chapter-four" id="chapter-four">四 数组的常用知识点</a>

> [返回目录](#chapter-one)

## <a name="chapter-five" id="chapter-five">五 总结</a>

> [返回目录](#chapter-one)

### 3.1 添加元素

* 添加到数组末尾

`push()` 添加元素到数组末尾

```js
let arr = [1, 2, 3];
arr.push(4);
```

也可以换成：

```js
let arr = [1, 2, 3];
arr[arr.length] = 4;
```

* 添加到数组头部

`unshift()` 添加元素到数组头部

```js
let arr = [2, 3, 4];
arr.unshift(1);
```

也可以换成：

```js
let arr = [2, 3, 4];
for (let i = arr.length; i >= 0; i--) {
  arr[i] = arr[i - 1];
}
arr[0] = 1;
```

### 3.2 删除元素

* 删除数组尾部

`pop()` 删除数组尾部元素

```js
let arr = [1, 2, 3, 4];
arr.pop();
```

也可以换成：

```js
let arr = [1, 2, 3, 4];
arr.length = 3;
```

* 删除数组头部

`shift()` 删除数组头部元素

```js
let arr = [1, 2, 3, 4];
arr.shift();
```

```js
let arr = [1, 2, 3, 4];
for (let i = 0; i < arr.length; i++) {
  arr[i] = arr[i + 1];
}
arr.length = 3;
```

### 3.3 任意位置删除和添加

`splice()` 可以实现任意位置的删除和添加

```js
let arr = [1, 2, 4, 5];
arr.splice(2, 0, 3);
// arr - [1, 2, 3, 4, 5]
```

## 四 API 集合

* `concat()` - 连接2个或更多数组，并返回结果
* `every()` - 对数组中的每一项运行给定函数，如果该函数对每一项都返回 `true`，则返回 `true`
* `filter()` - 对数组中的每一项运行给定函数，返回 `true` 的项组成的数组
* `forEach()` - 对数组中的每一项运行给定函数。这个方法没有返回值
* `join()` - 将所有的数组元素连接成一个字符串
* `indexOf()` - 返回第一个与给定参数相等的数组元素的索引，没有找到则返回 -1
* `lastIndexOf()` - 返回在数组中搜索到的与给定参数相等的元素的索引里最大的值
* `map()` - 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组
* `reverse()` - 颠倒数组中元素的顺序，原先第一个元素现在变成最后一个，同样原先的最后一个元素变成了现在 的第一个
* `slice()` - 传入索引值，将数组里对应索引范围内的元素作为新数组返回
* `some()` - 对数组中的每一项运行给定函数，如果任一项返回 `true`，则返回 `true`
* `sort()` - 按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数
* `toString()` - 将数组作为字符串返回
* `valueOf()` - 和 `toString()` 类似，将数组作为字符串返回

### 4.1 ES6/ES7 新增

* `@@iterator` - 返回一个包含数组键值对的迭代器对象，可以通过同步调用得到数组元素的键值对
* `copyWithin()` - 复制数组中一系列元素到同一数组指定的起始位置
* `entries()` - 返回包含数组所有键值对的 `@@iterator`
* `includes()` - 如果数组中存在某个元素则返回 `true`，否则返回 `false`。ES7 新增
* `find()` - 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素
* `findIndex()` - 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素在数组中的索引
* `fill()` - 用静态值填充数组
* `from()` - 根据已有数组创建一个新数组
* `keys()` - 返回包含数组所有索引的 `@@iterator`
* `of()` - 根据传入的参数创建一个新数组
* `values()` - 返回包含数组中所有值的 `@@iterator`

---

**不折腾的前端，和咸鱼有什么区别！**

![图](../../../public-repertory/img/z-small-wechat-public-address.jpg)

**jsliang** 会每天更新一道 LeetCode 题解，从而帮助小伙伴们夯实原生 JS 基础，了解与学习算法与数据结构。

扫描上方二维码，关注 **jsliang** 的公众号，让我们一起折腾！

> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">jsliang 的文档库</span> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/LiangJunrong/document-library" property="cc:attributionName" rel="cc:attributionURL">梁峻荣</a> 采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。<br />基于<a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/LiangJunrong/document-library" rel="dct:source">https://github.com/LiangJunrong/document-library</a>上的作品创作。<br />本许可协议授权之外的使用权限可以从 <a xmlns:cc="http://creativecommons.org/ns#" href="https://creativecommons.org/licenses/by-nc-sa/2.5/cn/" rel="cc:morePermissions">https://creativecommons.org/licenses/by-nc-sa/2.5/cn/</a> 处获得。