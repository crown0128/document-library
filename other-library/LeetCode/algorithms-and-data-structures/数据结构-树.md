数据结构 - 树
===

> Create by **jsliang** on **2019-6-13 09:02:12**  
> Recently revised in **2020-3-30 08:53:16**

## <a name="chapter-one" id="chapter-one">一 目录</a>

**不折腾的前端，和咸鱼有什么区别**

| 目录 |
| --- | 
| [一 目录](#chapter-one) | 
| <a name="catalog-chapter-two" id="catalog-chapter-two"></a>[二 前言](#chapter-two) |

## <a name="chapter-two" id="chapter-two">二 前言</a>

> [返回目录](#chapter-one)

**jsliang** 每次解 LeetCode，都会先自己尝试破解，Submit 通过后，会查看下 LeetCode 社区其他小伙伴的破解思路，最后再看别人的代码，以此作为比较，吸取大神们的经验。

这次，由于第一次解树的题目，所以抱着虚心的心态，前往观摩，还真碰到了个不错的讲解：

* [写树算法的套路框架](https://leetcode-cn.com/problems/same-tree/solution/xie-shu-suan-fa-de-tao-lu-kuang-jia-by-wei-lai-bu-/)

> 由于原文采用 C++ 的编程风格，**jsliang** 引入的时候会自动转换成 JavaScript

以下是其内容：

* 二叉树算法的设计的总路线：明确一个节点要做的事情，然后剩下的事抛给框架。

```js
let traverse = function(root) {
  // root 需要做什么？在这做。
  // 其他的不用 root 操心，抛给实现功能的函数
  traverse(root.left);
  traverse(root.right);
}
```

举两个简单的例子体会一下这个思路，热热身。

* 如何把二叉树所有的节点中的值加一？

```js
let plusOne = function(root) {
  if (!root) {
    return;
  }
  root.val += 1;
  plusOne(root.left);
  plusOne(root.right);
}
```

* 如何判断两棵二叉树是否完全相同？

```js
let isSameTree = function(root1, root2) {
  // 都为空的话，显然相同
  if (root1 == null && root2 == null) {
    return true;
  }
  // 一个为空，一个非空，显然不同
  if (root1 == null || root2 == null) {
    return false;
  }
  // 两个都非空，但 val 不一样也不行
  if (root1.val != root2.val) {
    return false;
  }
  // root1 和 root2 该比的都比完了，进行节点比较
  return isSameTree(root1.left, root2.left)
    && isSameTree(root1.right, root2.right);
}
```

大佬的解题套路如上，**jsliang** 觉得貌似有点道理，于是给记录下来，然后再之后碰到的树的题目中，不断尝试总结，终于能够挑战几乎 99% 以上的简单类型的 LeetCode 题！

那么，树是怎么，能吃吗？好玩吗？怎么操作？

下面，我们一一学习。

## <a name="chapter-three" id="chapter-three">三 草稿</a>

> [返回目录](#chapter-one)

和散列表一样，树也是一种非顺序数据结构，它对于存储需要快速查找的数据非常有用。

树是一种分层数据的抽象模型。

![图](../../../public-repertory/img/other-algorithms-and-data-structures-tree -1.png)

正如上图的班级结构图，就是一种树结构，它由食物链顶端：老师，分层控制各个学生。

> 灵机一动想起班级结构图，那就画了个班级结构图，看起来似乎有点丑了……

联想一下，你就会想起各种树结构：公司、班级、学校……

那么，树是一种怎样的结构呢？

```
    4
   / \
  3   5
 / \   \
1   2   6
```

如上图，就是一个常见的树表示图，如果你觉得不够清晰了解，咱们再看看树代码：

> 此处使用的是 Object 仿树结构，下面讲解树的各个知识点不会这样写，但是 LeetCode 刷题你可以这么用

```js
const root = {
  val: 4,
  left: {
    val: 3,
    left: { val: 1, left: null, right: null },
    right: { val: 2, left: null, right: null },
  },
  right: {
    val: 5,
    left: null,
    right: { val: 6, left: null, right: null },
  },
};
```

很好，看完上面，你就是熟知树的一员了，咱们来道题热热身吧：

* [【LeetCode】100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

```
给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1:

输入: 
   1         1
  / \       / \
 2   3     2   3

[1,2,3],   [1,2,3]

输出: true

示例 2:

输入:     
   1         1
  /           \
 2             2

[1,2],     [1,null,2]

输出: false

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/same-tree
著作权归领扣网络所有。
商业转载请联系官方授权，
非商业转载请注明出处。
```

给出函数体：

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {

};
```

请用上面的函数体进行解答。

---

看完小伙伴们有没有跃跃欲试的感觉，先看下 **jsliang** 的题解：

> 解法一：递归

```js
const root1 = {
  val: 1,
  left: { val: 2, left: null, right: null },
  right: { val: 3, left: null, right: null },
};
const root2 = {
  val: 1,
  left: { val: 2, left: null, right: null },
  right: { val: 4, left: null, right: null },
};

const isSameTree = (root1, root2) => {
  const ergodic = (root) => {
    if (!root) {
      return '!#';
    }
    return '!' + root.val + ergodic(root.left) + ergodic(root.right);
  }
  console.log(ergodic(root1));
  console.log(ergodic(root2));
  return ergodic(root1) === ergodic(root2);
};

isSameTree(root1, root2);
// !1!2!#!#!3!#!#
// !1!2!#!#!4!#!#
```

在树的破解中，你会经常性地接触一个方法：**递归**，下面我们会花点篇幅讲解它，先看题解：

1. 有两棵树，一棵是：`1->2->3`，一棵是：`1->2->4`，明眼人就知道这两个是不一样的，但是我们要让机器知道不一样啊。
2. 将 `root1` 转化为字符串，即：`!1!2!#!#!3!#!#`。
3. 将 `root2` 转化为字符串，即：`!1!2!#!#!4!#!#`。
4. 比较两者字符串，返回 `true/false`。

这样，就完成了题解，是不是觉得 so easy~

的确，既然是转字符串，然后你的数据结构类似于 `Object`，那么我可以直接上 `JSON.stringify()` 啊：

> 解法二：`JSON.stringify()`

```js
const isSameTree = (root1, root2) => {
  return JSON.stringify(root1) === JSON.stringify(root2);
};

isSameTree(root1, root2);
```

不管是本地的尝试还是直接在 LeetCode 点击提交，都可以看到我们的代码是成功的~

这样，树，小伙伴就入门了！

> 想起来一把辛酸泪，**jsliang** 是自己通过刷题逐渐明白的

## <a name="chapter-four" id="chapter-four">四 递归</a>

> [返回目录](#chapter-one)

乘我们刚热身完，将该了解的内容先了解下：

* 递归

递归是什么，函数自身调用自身，直到海枯石烂（递归终止）。

较为出名的可以用递归破解的就是 **斐波那契数列**。

* [【百度百科】斐波那契数列](https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145?fr=aladdin)

什么是 **菲薄拿起数列**：

斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。

它指的是这样一个数列：1、1、2、3、5、8、13、21、34……

即：第 3 项开始，每一项都是前两项之和，用 `for()` 来计算就是：

> 斐波那契数列 - for() 循环破解

```js
const fibonacci = (num) => {
  const arr = [1, 1];
  for (let i = 2; i < num; i++) {
    arr[i] = arr[i - 1] + arr[i - 2];
  }
  return arr;
};

console.log(fibonacci(10));
// [ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]
```

OK，相信 `for()` 这份代码小伙伴都看得懂，那么我们先将递归的代码贴上来，看下小伙伴们能不能理解：

> 斐波那契数列 - 递归破解

```js
const fibonacci = (index) => {
  if (index === 1 || index === 2) {
    return 1;
  }
  return fibonacci(index - 1) + fibonacci(index - 2);
};

console.log(fibonacci(10)); // 55
```

1. 调用 `fibonacci(index)`，这里的 `index` 是需要查找第几项。
2. 判断终止条件：`index === 1 || index === 2`，因为第一项和第二项都是 `1`。
3. 如果是第 3 项及以上的，就计算它前两项的和。

这么说小伙伴可能会有点懵圈，咱们看图：

> 最好是有视频调试，但是现在没想好怎么录视频或者做数据演示

![图](../../../public-repertory/img/other-algorithms-and-data-structures-tree -2.png)

顺着图，我们可以看到：

* `fibonacci(5) = fibonacci(4) + fibonacci(3)`
* `fibonacci(4) = fibonacci(3) + fibonacci(2)`
* `fibonacci(3) = fibonacci(2) + fibonacci(1)`
* `fibonacci(2) = 1`
* `fibonacci(1) = 1`

然后，我们再反推数据：

* `fibonacci(1) = 1`
* `fibonacci(2) = 1`
* `fibonacci(3) = 2`
* `fibonacci(4) = 3`
* `fibonacci(5) = 5`

所以最终结果是 `5`。

这样的逐步演进过程，就是递归。

那么我们做件有意思的事情，`for()` 和 `ergodic()` 哪个比较快？

```js
const fibonacciByFor = (num) => {
  const arr = [1, 1];
  for (let i = 2; i < num; i++) {
    arr[i] = arr[i - 1] + arr[i - 2];
  }
  return arr[arr.length - 1];
};

console.time('for 计算');
fibonacciByFor(20); // for 计算: 0.191ms
console.timeEnd('for 计算');

const fibonacciByErgodic = (index) => {
  if (index === 1 || index === 2) {
    return 1;
  }
  return fibonacciByErgodic(index - 1) + fibonacciByErgodic(index - 2);
};

console.time('ergodic 计算');
fibonacciByErgodic(20); // ergodic 计算: 1.655ms
console.timeEnd('ergodic 计算');
```

看表：

| 方法 | 耗时 |
| --- | --- |
| 线性遍历 | 0.191ms |
| 递归遍历 | 1.655ms |

如果小伙伴输入 30、50，甚至 100，会发现递归越来越慢返回结果，甚至你在浏览器上查看，会发现页面卡住了。

这就是递归的局限性。

OK，到这里小伙伴可能会有点兴奋：我知道啥是递归，啥是斐波那契数列了，有没有法子练习？！

有的：

| 顺序 | 题目 | 解题攻略 |
| --- | --- | --- |
| 待补充 | 509 - 斐波那契数列（fibonacci-number） | [#509 解题](./509-斐波那契数列（fibonacci-number）.md) |
| 待补充 | 待补充 | 待补充 |

这样，我们就进一步学习到了递归，并进行了题目练习。

## <a name="chapter-five" id="chapter-five">五 树相关术语</a>

> [返回目录](#chapter-one)

话归正题，我们讲清楚了递归，是时候看看树的一些相关术语，然后开始树的构造玩耍了。

> 虽然本小节可能有点无聊，但是了解树的相关术语有助于你进一步了解树。

![图](../../../public-repertory/img/other-algorithms-and-data-structures-tree -3.png)

> 图来自于《学习 JavaScript 数据结构与算法》

如上图：

* **根节点**：位于顶端，没有父节点，整棵树都是它的弟弟。
* **父节点**：`11` 是 `7` 的父节点，`7` 是 `5` 的父节点。
* **子节点**：`7` 是 `11` 的子节点，`5` 是 `7` 的子节点。
* **后代**：`11` 的子节点有 `7` 和 `15`，孙子节点有 `5`、`9`、`13`、`20`，曾孙节点有 `3`、`6`、`8`、`10`……
* **祖先**：`3` 的父节点为 `5`，祖父节点有 `7`，曾祖父节点有 `11`……
* **子树**：`5 & 3 & 6` 构成一颗子树，`13 & 12 & 14` 也构成一颗子树。
* **深度**：按照数组的逻辑，万物从 0 开始，所以根节点的深度为 0，然后第 1 层、第 2 层……
* **左侧子节点**：`7` 是 `11` 的左侧子节点。
* **右侧子节点**：`15` 是 `11` 的右侧子节点。

## <a name="chapter-six" id="chapter-six">六 二叉树和二叉搜索树</a>

> [返回目录](#chapter-one)

很好，了解完树的相关术语之后，我们开始了解二叉树以及二叉树的种类之一：二叉搜索树。

* 什么是二叉树？

很简单，一儿一女，一左一右，即为二叉。

> 二叉树

```
  1
 / \
2   3
```

二叉树最多只有两个子节点：一个左侧子节点，一个右侧子节点。

这些定义有助于我们写出更高效的从树中插入、查找和删除节点的算法。

* 什么是二叉搜索树？

二叉搜索树（BST）是二叉树的一种，但是它遵循一个原则：左小右大。

不同于古时候男左女右，左为尊的规则，二叉搜索树符合现代的读书，从左往右看，故而左小右大。

> 二叉搜索树

```
     4
   /   \
  2     6
 / \   / \
1   3 5   7
```

1. 以 4 为分界，左边 1/2/3 小于 4，右边 5/6/7 大于 4。
2. 以 2 为分界，左边 1 小于 2，右边 3 大于 2。
3. 以 6 为分界，左边 5 小于 6，右边 7 大于 6。

在设计二叉搜索树的时候，需要注意一个问题，即所有父节点（包括根节点），都符合左小右大的规则，往往很多时候设计树或者做二叉搜索树的题目时，这点是容易忽略的（包括 **jsliang**）。

那么下面我们开始设计二叉搜索树：

```js

```

## <a name="chapter-four" id="chapter-four">四 参考文献</a>

> [返回目录](#chapter-one)

*  [【LeetCode 题解区】写树算法的套路框架](https://leetcode-cn.com/problems/same-tree/solution/xie-shu-suan-fa-de-tao-lu-kuang-jia-by-wei-lai-bu-/)
* [【百度百科】斐波那契数列](https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145?fr=aladdin)
* [【百度*百家号】漫画：什么是红黑树](https://baijiahao.baidu.com/s?id=1641940303518144126&wfr=spider&for=pc)
* [【简书】執著我們的執著《8. 红黑树与AVL树，各自的优缺点总结》](https://www.jianshu.com/p/37436ed14cc6)
* [【百度百科】红黑树](https://baike.baidu.com/item/%E7%BA%A2%E9%BB%91%E6%A0%91/2413209?fr=aladdin)

---

**不折腾的前端，和咸鱼有什么区别！**

![图](../../../public-repertory/img/z-index-small.png)

**jsliang** 会每天更新一道 LeetCode 题解，从而帮助小伙伴们夯实原生 JS 基础，了解与学习算法与数据结构。

**浪子神剑** 会每天更新面试题，以面试题为驱动来带动大家学习，坚持每天学习与思考，每天进步一点！

扫描上方二维码，关注 **jsliang** 的公众号（左）和 **浪子神剑** 的公众号（右），让我们一起折腾！

> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">jsliang 的文档库</span> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/LiangJunrong/document-library" property="cc:attributionName" rel="cc:attributionURL">梁峻荣</a> 采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。<br />基于<a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/LiangJunrong/document-library" rel="dct:source">https://github.com/LiangJunrong/document-library</a>上的作品创作。<br />本许可协议授权之外的使用权限可以从 <a xmlns:cc="http://creativecommons.org/ns#" href="https://creativecommons.org/licenses/by-nc-sa/2.5/cn/" rel="cc:morePermissions">https://creativecommons.org/licenses/by-nc-sa/2.5/cn/</a> 处获得。