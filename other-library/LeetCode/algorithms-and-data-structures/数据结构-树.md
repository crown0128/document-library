数据结构 - 树
===

> Create by **jsliang** on **2019-6-13 09:02:12**  
> Recently revised in **2020-03-31 16:47:19**

## <a name="chapter-one" id="chapter-one">一 目录</a>

**不折腾的前端，和咸鱼有什么区别**

| 目录 |
| --- | 
| [一 目录](#chapter-one) | 
| <a name="catalog-chapter-two" id="catalog-chapter-two"></a>[二 前言](#chapter-two) |

## <a name="chapter-two" id="chapter-two">二 前言</a>

> [返回目录](#chapter-one)

**jsliang** 每次解 LeetCode，都会先自己尝试破解，Submit 通过后，会查看下 LeetCode 社区其他小伙伴的破解思路，最后再看别人的代码，以此作为比较，吸取大神们的经验。

这次，由于第一次解树的题目，所以抱着虚心的心态，前往观摩，还真碰到了个不错的讲解：

* [写树算法的套路框架](https://leetcode-cn.com/problems/same-tree/solution/xie-shu-suan-fa-de-tao-lu-kuang-jia-by-wei-lai-bu-/)

> 由于原文采用 C++ 的编程风格，**jsliang** 引入的时候会自动转换成 JavaScript

以下是其内容：

* 二叉树算法的设计的总路线：明确一个节点要做的事情，然后剩下的事抛给框架。

```js
let traverse = function(root) {
  // root 需要做什么？在这做。
  // 其他的不用 root 操心，抛给实现功能的函数
  traverse(root.left);
  traverse(root.right);
}
```

举两个简单的例子体会一下这个思路，热热身。

* 如何把二叉树所有的节点中的值加一？

```js
let plusOne = function(root) {
  if (!root) {
    return;
  }
  root.val += 1;
  plusOne(root.left);
  plusOne(root.right);
}
```

* 如何判断两棵二叉树是否完全相同？

```js
let isSameTree = function(root1, root2) {
  // 都为空的话，显然相同
  if (root1 == null && root2 == null) {
    return true;
  }
  // 一个为空，一个非空，显然不同
  if (root1 == null || root2 == null) {
    return false;
  }
  // 两个都非空，但 val 不一样也不行
  if (root1.val != root2.val) {
    return false;
  }
  // root1 和 root2 该比的都比完了，进行节点比较
  return isSameTree(root1.left, root2.left)
    && isSameTree(root1.right, root2.right);
}
```

大佬的解题套路如上，**jsliang** 觉得貌似有点道理，于是给记录下来，然后再之后碰到的树的题目中，不断尝试总结，终于能够挑战几乎 99% 以上的简单类型的 LeetCode 题！

那么，树是怎么，能吃吗？好玩吗？怎么操作？

下面，我们一一学习。

## <a name="chapter-three" id="chapter-three">三 草稿</a>

> [返回目录](#chapter-one)

和散列表一样，树也是一种非顺序数据结构，它对于存储需要快速查找的数据非常有用。

树是一种分层数据的抽象模型。

![图](../../../public-repertory/img/other-algorithms-and-data-structures-tree -1.png)

正如上图的班级结构图，就是一种树结构，它由食物链顶端：老师，分层控制各个学生。

> 灵机一动想起班级结构图，那就画了个班级结构图，看起来似乎有点丑了……

联想一下，你就会想起各种树结构：公司、班级、学校……

那么，树是一种怎样的结构呢？

```
    4
   / \
  3   5
 / \   \
1   2   6
```

如上图，就是一个常见的树表示图，如果你觉得不够清晰了解，咱们再看看树代码：

> 此处使用的是 Object 仿树结构，下面讲解树的各个知识点不会这样写，但是 LeetCode 刷题你可以这么用

```js
const root = {
  val: 4,
  left: {
    val: 3,
    left: { val: 1, left: null, right: null },
    right: { val: 2, left: null, right: null },
  },
  right: {
    val: 5,
    left: null,
    right: { val: 6, left: null, right: null },
  },
};
```

很好，看完上面，你就是熟知树的一员了，咱们来道题热热身吧：

* [【LeetCode】100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

```
给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1:

输入: 
   1         1
  / \       / \
 2   3     2   3

[1,2,3],   [1,2,3]

输出: true

示例 2:

输入:     
   1         1
  /           \
 2             2

[1,2],     [1,null,2]

输出: false

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/same-tree
著作权归领扣网络所有。
商业转载请联系官方授权，
非商业转载请注明出处。
```

给出函数体：

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {

};
```

请用上面的函数体进行解答。

---

看完小伙伴们有没有跃跃欲试的感觉，先看下 **jsliang** 的题解：

> 解法一：递归

```js
const root1 = {
  val: 1,
  left: { val: 2, left: null, right: null },
  right: { val: 3, left: null, right: null },
};
const root2 = {
  val: 1,
  left: { val: 2, left: null, right: null },
  right: { val: 4, left: null, right: null },
};

const isSameTree = (root1, root2) => {
  const ergodic = (root) => {
    if (!root) {
      return '!#';
    }
    return '!' + root.val + ergodic(root.left) + ergodic(root.right);
  }
  console.log(ergodic(root1));
  console.log(ergodic(root2));
  return ergodic(root1) === ergodic(root2);
};

isSameTree(root1, root2);
// !1!2!#!#!3!#!#
// !1!2!#!#!4!#!#
```

在树的破解中，你会经常性地接触一个方法：**递归**，下面我们会花点篇幅讲解它，先看题解：

1. 有两棵树，一棵是：`1->2->3`，一棵是：`1->2->4`，明眼人就知道这两个是不一样的，但是我们要让机器知道不一样啊。
2. 将 `root1` 转化为字符串，即：`!1!2!#!#!3!#!#`。
3. 将 `root2` 转化为字符串，即：`!1!2!#!#!4!#!#`。
4. 比较两者字符串，返回 `true/false`。

这样，就完成了题解，是不是觉得 so easy~

的确，既然是转字符串，然后你的数据结构类似于 `Object`，那么我可以直接上 `JSON.stringify()` 啊：

> 解法二：`JSON.stringify()`

```js
const isSameTree = (root1, root2) => {
  return JSON.stringify(root1) === JSON.stringify(root2);
};

isSameTree(root1, root2);
```

不管是本地的尝试还是直接在 LeetCode 点击提交，都可以看到我们的代码是成功的~

这样，树，小伙伴就入门了！

> 想起来一把辛酸泪，**jsliang** 是自己通过刷题逐渐明白的

## <a name="chapter-four" id="chapter-four">四 递归</a>

> [返回目录](#chapter-one)

乘我们刚热身完，将该了解的内容先了解下：

* 递归

递归是什么，函数自身调用自身，直到海枯石烂（递归终止）。

较为出名的可以用递归破解的就是 **斐波那契数列**。

* [【百度百科】斐波那契数列](https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145?fr=aladdin)

什么是 **菲薄拿起数列**：

斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。

它指的是这样一个数列：1、1、2、3、5、8、13、21、34……

即：第 3 项开始，每一项都是前两项之和，用 `for()` 来计算就是：

> 斐波那契数列 - for() 循环破解

```js
const fibonacci = (num) => {
  const arr = [1, 1];
  for (let i = 2; i < num; i++) {
    arr[i] = arr[i - 1] + arr[i - 2];
  }
  return arr;
};

console.log(fibonacci(10));
// [ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ]
```

OK，相信 `for()` 这份代码小伙伴都看得懂，那么我们先将递归的代码贴上来，看下小伙伴们能不能理解：

> 斐波那契数列 - 递归破解

```js
const fibonacci = (index) => {
  if (index === 1 || index === 2) {
    return 1;
  }
  return fibonacci(index - 1) + fibonacci(index - 2);
};

console.log(fibonacci(10)); // 55
```

1. 调用 `fibonacci(index)`，这里的 `index` 是需要查找第几项。
2. 判断终止条件：`index === 1 || index === 2`，因为第一项和第二项都是 `1`。
3. 如果是第 3 项及以上的，就计算它前两项的和。

这么说小伙伴可能会有点懵圈，咱们看图：

> 最好是有视频调试，但是现在没想好怎么录视频或者做数据演示

![图](../../../public-repertory/img/other-algorithms-and-data-structures-tree -2.png)

顺着图，我们可以看到：

* `fibonacci(5) = fibonacci(4) + fibonacci(3)`
* `fibonacci(4) = fibonacci(3) + fibonacci(2)`
* `fibonacci(3) = fibonacci(2) + fibonacci(1)`
* `fibonacci(2) = 1`
* `fibonacci(1) = 1`

然后，我们再反推数据：

* `fibonacci(1) = 1`
* `fibonacci(2) = 1`
* `fibonacci(3) = 2`
* `fibonacci(4) = 3`
* `fibonacci(5) = 5`

所以最终结果是 `5`。

这样的逐步演进过程，就是递归。

那么我们做件有意思的事情，`for()` 和 `ergodic()` 哪个比较快？

```js
const fibonacciByFor = (num) => {
  const arr = [1, 1];
  for (let i = 2; i < num; i++) {
    arr[i] = arr[i - 1] + arr[i - 2];
  }
  return arr[arr.length - 1];
};

console.time('for 计算');
fibonacciByFor(20); // for 计算: 0.191ms
console.timeEnd('for 计算');

const fibonacciByErgodic = (index) => {
  if (index === 1 || index === 2) {
    return 1;
  }
  return fibonacciByErgodic(index - 1) + fibonacciByErgodic(index - 2);
};

console.time('ergodic 计算');
fibonacciByErgodic(20); // ergodic 计算: 1.655ms
console.timeEnd('ergodic 计算');
```

看表：

| 方法 | 耗时 |
| --- | --- |
| 线性遍历 | 0.191ms |
| 递归遍历 | 1.655ms |

如果小伙伴输入 30、50，甚至 100，会发现递归越来越慢返回结果，甚至你在浏览器上查看，会发现页面卡住了。

这就是递归的局限性。

OK，到这里小伙伴可能会有点兴奋：我知道啥是递归，啥是斐波那契数列了，有没有法子练习？！

有的：

| 顺序 | 题目 | 解题攻略 |
| --- | --- | --- |
| 待补充 | 509 - 斐波那契数列（fibonacci-number） | [#509 解题](./509-斐波那契数列（fibonacci-number）.md) |
| 待补充 | 待补充 | 待补充 |

这样，我们就进一步学习到了递归，并进行了题目练习。

## <a name="chapter-five" id="chapter-five">五 树相关术语</a>

> [返回目录](#chapter-one)

话归正题，我们讲清楚了递归，是时候看看树的一些相关术语，然后开始树的构造玩耍了。

> 虽然本小节可能有点无聊，但是了解树的相关术语有助于你进一步了解树。

![图](../../../public-repertory/img/other-algorithms-and-data-structures-tree -3.png)

> 图来自于《学习 JavaScript 数据结构与算法》

如上图：

* **根节点**：位于顶端，没有父节点，整棵树都是它的弟弟。
* **父节点**：`11` 是 `7` 的父节点，`7` 是 `5` 的父节点。
* **子节点**：`7` 是 `11` 的子节点，`5` 是 `7` 的子节点。
* **后代**：`11` 的子节点有 `7` 和 `15`，孙子节点有 `5`、`9`、`13`、`20`，曾孙节点有 `3`、`6`、`8`、`10`……
* **祖先**：`3` 的父节点为 `5`，祖父节点有 `7`，曾祖父节点有 `11`……
* **子树**：`5 & 3 & 6` 构成一颗子树，`13 & 12 & 14` 也构成一颗子树。
* **深度**：按照数组的逻辑，万物从 0 开始，所以根节点的深度为 0，然后第 1 层、第 2 层……
* **左侧子节点**：`7` 是 `11` 的左侧子节点。
* **右侧子节点**：`15` 是 `11` 的右侧子节点。

## <a name="chapter-six" id="chapter-six">六 二叉树和二叉搜索树</a>

> [返回目录](#chapter-one)

很好，了解完树的相关术语之后，我们开始了解二叉树以及二叉树的种类之一：二叉搜索树。

* 什么是二叉树？

很简单，一儿一女，一左一右，即为二叉。

> 二叉树

```
  1
 / \
2   3
```

二叉树最多只有两个子节点：一个左侧子节点，一个右侧子节点。

这些定义有助于我们写出更高效的从树中插入、查找和删除节点的算法。

* 什么是二叉搜索树？

二叉搜索树（BST）是二叉树的一种，但是它遵循一个原则：左小右大。

不同于古时候男左女右，左为尊的规则，二叉搜索树符合现代的读书，从左往右看，故而左小右大。

> 二叉搜索树

```
     4
   /   \
  2     6
 / \   / \
1   3 5   7
```

1. 以 4 为分界，左边 1/2/3 小于 4，右边 5/6/7 大于 4。
2. 以 2 为分界，左边 1 小于 2，右边 3 大于 2。
3. 以 6 为分界，左边 5 小于 6，右边 7 大于 6。

在设计二叉搜索树的时候，需要注意一个问题，即所有父节点（包括根节点），都符合左小右大的规则，往往很多时候设计树或者做二叉搜索树的题目时，这点是容易忽略的（包括 **jsliang**）。

再来就是，我们需要了解一些 **术语**，方便和一些 **专家** 沟通：

* **边**：由 4 到 2，或者 2 到 1 的箭头，称为边。
* **键**：将二叉树的节点本身称为键，例如 4、2、1 等。

那么下面我们开始设计二叉搜索树：

```js
const BinarySearchTree = function {
  const Node = function(key) {
    this.key = key;
    this.left = null;
    this.right = null;
  };

  const root = null;

  // 向树中插入一个新的键
  this.insert = function(key) {};

  // 在树中查找一个键，如果节点存在，则返回 true，否则返回 false
  this.search = function(key) {};

  // 通过中序遍历方式遍历所有节点
  this.inOrderTraverse = function() {};

  // 通过先序遍历方式遍历所有节点
  this.prevOrderTranverse = function() {};
  
  // 通过后序遍历方式遍历所有节点
  this.postOrderTranverse = function() {};

  // 返回树中最小的值/键
  this.min = function() {};

  // 返回树中最大的值/键
  this.max = function() {};
  
  // 从树中移除某个键
  this.remove = function() {};
}
```

* `insert(key)`：向树中插入一个新的键
* `search(key)`：在树中查找一个键，如果节点存在，则返回 true，否则返回 false
* `inOrderTraverse()`：通过中序遍历方式遍历所有节点
* `prevOrderTranverse()`：通过先序遍历方式遍历所有节点
* `postOrderTranverse()`：通过后序遍历方式遍历所有节点
* `min()`：返回树中最小的值/键
* `max()`：返回树中最大的值/键
* `remove()`：从树中移除某个键

### <a name="chapter-six-one" id="chapter-six-one">6.1 插入键：insert()</a>

> [返回目录](#chapter-one)

```js
const BinarySearchTree = function() {
  const Node = function(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  };

  // 不使用 const，因为下面会改变它
  let root = null;

  // 插入方法辅助
  const insertNode = (node, newNode) => {
    // 1. 值应该插入到左边
    if (newNode.value < node.value) {
      // 1.1 空节点直接插入
      if (node.left === null) {
        node.left = newNode;
      } else { // 1.2 否则递归直到能插入到尾部
        insertNode(node.left, newNode);
      }
    } else if (newNode.value >= node.value) { // 2. 值应该插入到右边（不用 else 方便观察）
      // 2.1 空节点直接插入
      if (node.right === null) {
        node.right = newNode;
      } else { // 2.2 否则递归直到能插入到尾部
        insertNode(node.right, newNode);
      }
    }
  }

  // 向树中插入一个新的键
  this.insert = function(value) {
    // 1. 构造新节点
    const newNode = new Node(value);

    // 2. 空节点直接插入
    if (root === null) {
      root = newNode;
    } else {
      // 3. 非空节点需要查看插入位置
      insertNode(root, newNode);
    }

    // 4. 支持链式调用
    return this;
  };

  // 在树中查找一个键，如果节点存在，则返回 true，否则返回 false

  this.search = function(value) {};

  // 通过中序遍历方式遍历所有节点
  this.inOrderTraverse = function() {};

  // 通过先序遍历方式遍历所有节点
  this.prevOrderTranverse = function() {};
  
  // 通过后序遍历方式遍历所有节点
  this.postOrderTranverse = function() {};

  // 返回树中最小的值/键
  this.min = function() {};

  // 返回树中最大的值/键
  this.max = function() {};

  // 从树中移除某个键
  this.remove = function() {};

  // 打印 root
  this.print = function() {
    console.log(root);
  };
}

const tree = new BinarySearchTree();

tree.insert(2).insert(1).insert(3).insert(4);
tree.print();
/*
Node {
  value: 2,
  left: Node { value: 1, left: null, right: null },
  right: Node {
    value: 3,
    left: null,
    right: Node { value: 4, left: null, right: null },
  },
}
  2
 / \
1   3
     \
      4
*/
```

这样，我们就完成了树的插入操作，很简单：

1. 判断是否空节点，是的话直接插入，不是的话执行步骤 2。
2. 判断这个键值比左大还是比右大，层层演进（递归），直到找到能插入的位置。

那么，在这里留个悬疑：

```js
tree.insert(2).insert(1).insert(3).insert(4).insert(5).insert(6).insert(7);
```

这行代码产生的树会变成这个：

```
  2
 / \
1   3
     \
      4
       \
        5
         \
          6
           \
            7
```

这样的树虽然也是搜索二叉树，但是它是我们想要的吗？如果不是，我们有没有更好的法子让它更好呢？

```
     4
   /   \
  2     6
 / \   / \
1   3 5   7
```

---

在设计树的过程中，一不小心我们很容易直接来：

* `root === null`

其实这样的判断，在工作中也有很多，例如：

* `val === undefined`
* `val === ''`
* `val === 0`
* `val === null`

它们都是可以省略的，即：

* `!root`

这样，我们写起来就方便很多。

那么，这时候考点来了：

```js
const v1 = 0, v2 = '0', v3 = '';

console.log(!v1);
console.log(!v2);
console.log(!v3);
console.log(v2 == false);
```

分别输出什么？为什么？

答案：

* `console.log(!v1)`：`true`
* `console.log(!v2)`：`false`
* `console.log(!v3)`：`true`
* `console.log(v2 == false)`：`true`

### <a name="chapter-six-three" id="chapter-six-three">6.3 先序遍历：prevOrderTranverse()</a>

> [返回目录](#chapter-one)

* 什么是先序遍历？

假设我们有树：

```
     4
   /   \
  2     6
 / \   / \
1   3 5   7
```

那么，先序遍历的顺序为：

`4 -> 1 -> 2 -> 3 -> 6 -> 5 -> 7`

即：先序遍历先访问根节点，然后遍历左子树，最后遍历右子树。

另：先序遍历也叫作先根遍历、前序遍历

> 示例 1

```
  4
 / \
2   6
   / \
  5   7
```

这棵树的先序遍历为：`4 -> 2 -> 6 -> 5 -> 7`

> 示例 2

```
  4
 / \
2   8
   / \
  6   9
 / \
5   7
```

这棵树的先序遍历为：`4 -> 2 -> 8 -> 6 -> 5 -> 7 -> 9`

话不多说看代码：

```js
const BinarySearchTree = function() {
  const Node = function(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  };

  // 不使用 const，因为下面会改变它
  let root = null;

  // 插入方法辅助
  const insertNode = (node, newNode) => {
    // 1. 值应该插入到左边
    if (newNode.value < node.value) {
      // 1.1 空节点直接插入
      if (!node.left) {
        node.left = newNode;
      } else { // 1.2 否则递归直到能插入到尾部
        insertNode(node.left, newNode);
      }
    } else if (newNode.value >= node.value) { // 2. 值应该插入到右边（不用 else 方便观察）
      // 2.1 空节点直接插入
      if (!node.right) {
        node.right = newNode;
      } else { // 2.2 否则递归直到能插入到尾部
        insertNode(node.right, newNode);
      }
    }
  }

  // 向树中插入一个新的键
  this.insert = function(value) {
    // 1. 构造新节点
    const newNode = new Node(value);

    // 2. 空节点直接插入
    if (!root) {
      root = newNode;
    } else {
      // 3. 非空节点需要查看插入位置
      insertNode(root, newNode);
    }

    // 4. 支持链式调用
    return this;
  };

  // 在树中查找一个键，如果节点存在，则返回 true，否则返回 false
  this.search = function(value) {};

  // 通过先序遍历方式遍历所有节点
  this.prevOrderTranverse = function() {
    const ergodic = (root) => {
      if (!root) {
        return '|#';
      }
      return '|' + root.value + ergodic(root.left) + ergodic(root.right);
    }
    console.log(ergodic(root));
  };

  // 通过中序遍历方式遍历所有节点
  this.inOrderTraverse = function() { };
  
  // 通过后序遍历方式遍历所有节点
  this.postOrderTranverse = function() {};

  // 返回树中最小的值/键
  this.min = function() {};

  // 返回树中最大的值/键
  this.max = function() {};

  // 从树中移除某个键
  this.remove = function() {};

  // 打印 root
  this.print = function() {
    console.log(root);
  };
}

const tree = new BinarySearchTree();

tree.insert(2).insert(1).insert(3).insert(4);
// tree.print();
/*
Node {
  value: 2,
  left: Node { value: 1, left: null, right: null },
  right: Node {
    value: 3,
    left: null,
    right: Node { value: 4, left: null, right: null },
  },
}
  2
 / \
1   3
     \
      4
*/

// 先序遍历
tree.prevOrderTranverse(); // |2|1|#|#|3|#|4|#|#
```

话说回来，中序遍历和先序遍历是 **jsliang** 根据它演示逻辑写出来的，那么相信小伙伴们应该看完后，也能自己写一种遍历顺序了，挑战下下面的 **后序遍历** 吧！

### <a name="chapter-six-two" id="chapter-six-two">6.2 中序遍历：inOrderTraverse()</a>

> [返回目录](#chapter-one)

* 什么是中序遍历、先序遍历以及后续遍历？

在了解这个之前我们讲下这个 **遍历**，遍历是对一棵树所有节点做访问的形式，即我们所说的中序/先序/后续遍历都是通过不同的顺序，对一棵树的所有节点进行访问。

* 什么是中序遍历？

假设我们有树：

```
     4
   /   \
  2     6
 / \   / \
1   3 5   7
```

那么，中序遍历的顺序为：

`1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7`

即：中序遍历先遍历左子树，然后访问根节点，最后遍历右子树。

另：中序遍历也叫中根遍历、中序周游。

> 示例 1

```
  4
 / \
2   6
   / \
  5   7
```

这棵树的中序遍历为：`2 -> 4 -> 5 -> 6 -> 7`

> 示例 2

```
  4
 / \
2   8
   / \
  6   9
 / \
5   7
```

这棵树的中序遍历为：`2 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9`

当然，上面都是二叉搜索树，给小伙伴的感觉可能是从小到大排列，但是有时候非二叉搜索树的时候希望小伙伴们能按照前面的定义进行排序，避免慌乱。

下面我们实现中序遍历：

```js
const BinarySearchTree = function() {
  const Node = function(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  };

  // 不使用 const，因为下面会改变它
  let root = null;

  // 插入方法辅助
  const insertNode = (node, newNode) => {
    // 1. 值应该插入到左边
    if (newNode.value < node.value) {
      // 1.1 空节点直接插入
      if (!node.left) {
        node.left = newNode;
      } else { // 1.2 否则递归直到能插入到尾部
        insertNode(node.left, newNode);
      }
    } else if (newNode.value >= node.value) { // 2. 值应该插入到右边（不用 else 方便观察）
      // 2.1 空节点直接插入
      if (!node.right) {
        node.right = newNode;
      } else { // 2.2 否则递归直到能插入到尾部
        insertNode(node.right, newNode);
      }
    }
  }

  // 向树中插入一个新的键
  this.insert = function(value) {
    // 1. 构造新节点
    const newNode = new Node(value);

    // 2. 空节点直接插入
    if (!root) {
      root = newNode;
    } else {
      // 3. 非空节点需要查看插入位置
      insertNode(root, newNode);
    }

    // 4. 支持链式调用
    return this;
  };

  // 在树中查找一个键，如果节点存在，则返回 true，否则返回 false
  this.search = function(value) {};

  // 通过中序遍历方式遍历所有节点
  this.inOrderTraverse = function() {
    const ergodic = (root) => {
      if (!root) {
        return '|#';
      }
      return ergodic(root.left) + '|' + root.value + ergodic(root.right);
    }
    console.log(ergodic(root));
  };

  // 通过先序遍历方式遍历所有节点
  this.prevOrderTranverse = function() {
    const ergodic = (root) => {
      if (!root) {
        return '|#';
      }
      return '|' + root.value + ergodic(root.left) + ergodic(root.right);
    }
    console.log(ergodic(root));
  };
  
  // 通过后序遍历方式遍历所有节点
  this.postOrderTranverse = function() {};

  // 返回树中最小的值/键
  this.min = function() {};

  // 返回树中最大的值/键
  this.max = function() {};

  // 从树中移除某个键
  this.remove = function() {};

  // 打印 root
  this.print = function() {
    console.log(root);
  };
}

const tree = new BinarySearchTree();

tree.insert(2).insert(1).insert(3).insert(4);
// tree.print();
/*
Node {
  value: 2,
  left: Node { value: 1, left: null, right: null },
  right: Node {
    value: 3,
    left: null,
    right: Node { value: 4, left: null, right: null },
  },
}
  2
 / \
1   3
     \
      4
*/

// 先序遍历
tree.prevOrderTranverse(); // |2|1|#|#|3|#|4|#|#

// 中序遍历
tree.inOrderTraverse(); // |#|1|#|2|#|3|#|4|#
```

### <a name="chapter-six-four" id="chapter-six-four">6.4 后序遍历：postOrderTraverse()</a>

> [返回目录](#chapter-one)

* 什么是后序遍历？

假设我们有树：

```
     4
   /   \
  2     6
 / \   / \
1   3 5   7
```

那么，后序遍历的顺序为：

`1 -> 3 -> 2 -> 5 -> 7 -> 6 -> 4`

即：后序遍历先遍历左子树，然后遍历右子树，最后访问根节点

另：后序遍历也叫后根遍历、后序周游

> 示例 1

```
  4
 / \
2   6
   / \
  5   7
```

这棵树的后序遍历为：`2 -> 5 -> 7 -> 6 -> 4`

> 示例 2

```
  4
 / \
2   8
   / \
  6   9
 / \
5   7
```

这棵树的后序遍历为：`2 -> 5 -> 7 -> 6 -> 9 -> 8 -> 4`

那么，经过前面两种的遍历方式，小伙伴们应该能写出来后序遍历了，尝试一下吧！

如果实在不行那就看代码：

```js
const BinarySearchTree = function() {
  const Node = function(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  };

  // 不使用 const，因为下面会改变它
  let root = null;

  // 插入方法辅助
  const insertNode = (node, newNode) => {
    // 1. 值应该插入到左边
    if (newNode.value < node.value) {
      // 1.1 空节点直接插入
      if (!node.left) {
        node.left = newNode;
      } else { // 1.2 否则递归直到能插入到尾部
        insertNode(node.left, newNode);
      }
    } else if (newNode.value >= node.value) { // 2. 值应该插入到右边（不用 else 方便观察）
      // 2.1 空节点直接插入
      if (!node.right) {
        node.right = newNode;
      } else { // 2.2 否则递归直到能插入到尾部
        insertNode(node.right, newNode);
      }
    }
  }

  // 向树中插入一个新的键
  this.insert = function(value) {
    // 1. 构造新节点
    const newNode = new Node(value);

    // 2. 空节点直接插入
    if (!root) {
      root = newNode;
    } else {
      // 3. 非空节点需要查看插入位置
      insertNode(root, newNode);
    }

    // 4. 支持链式调用
    return this;
  };

  // 在树中查找一个键，如果节点存在，则返回 true，否则返回 false
  this.search = function(value) {};

  // 通过中序遍历方式遍历所有节点
  this.inOrderTraverse = function() {
    const ergodic = (root) => {
      if (!root) {
        return '|#';
      }
      return ergodic(root.left) + '|' + root.value + ergodic(root.right);
    }
    console.log(ergodic(root));
  };

  // 通过先序遍历方式遍历所有节点
  this.prevOrderTranverse = function() {
    const ergodic = (root) => {
      if (!root) {
        return '|#';
      }
      return '|' + root.value + ergodic(root.left) + ergodic(root.right);
    }
    console.log(ergodic(root));
  };
  
  // 通过后序遍历方式遍历所有节点
  this.postOrderTranverse = function() {
    const ergodic = (root) => {
      if (!root) {
        return '|#';
      }
      return ergodic(root.left) + ergodic(root.right) + '|' + root.value;
    }
    console.log(ergodic(root));
  };

  // 返回树中最小的值/键
  this.min = function() {};

  // 返回树中最大的值/键
  this.max = function() {};

  // 从树中移除某个键
  this.remove = function() {};

  // 打印 root
  this.print = function() {
    console.log(root);
  };
}

const tree = new BinarySearchTree();

tree.insert(2).insert(1).insert(3).insert(4);
// tree.print();
/*
Node {
  value: 2,
  left: Node { value: 1, left: null, right: null },
  right: Node {
    value: 3,
    left: null,
    right: Node { value: 4, left: null, right: null },
  },
}
  2
 / \
1   3
     \
      4
*/

// 先序遍历
tree.prevOrderTranverse(); // |2|1|#|#|3|#|4|#|#

// 中序遍历
tree.inOrderTraverse(); // |#|1|#|2|#|3|#|4|#

// 后序遍历
tree.postOrderTranverse(); // |#|#|1|#|#|#|4|3|2
```

那么，到此为止，我们看下树的内容：

对于树：

```
  2
 / \
1   3
     \
      4
```

* **先序遍历**：`|2|1|#|#|3|#|4|#|#`。先访问根节点，然后遍历左子树，最后遍历右子树。
* **中序遍历**：`|#|1|#|2|#|3|#|4|#`。先遍历左子树，然后访问根节点，最后遍历右子树。
* **后序遍历**：`|#|#|1|#|#|#|4|3|2`。先遍历左子树，然后遍历右子树，最后访问根节点。

### <a name="chapter-six-five" id="chapter-six-five">6.5 最小值 min() 和 最大值 max()</a>

> [返回目录](#chapter-one)

### <a name="chapter-six-six" id="chapter-six-six">6.6 移除键：remove()</a>

> [返回目录](#chapter-one)


## <a name="chapter-four" id="chapter-four">四 参考文献</a>

> [返回目录](#chapter-one)

*  [【LeetCode 题解区】写树算法的套路框架](https://leetcode-cn.com/problems/same-tree/solution/xie-shu-suan-fa-de-tao-lu-kuang-jia-by-wei-lai-bu-/)
* [【百度百科】斐波那契数列](https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145?fr=aladdin)
* [【百度*百家号】漫画：什么是红黑树](https://baijiahao.baidu.com/s?id=1641940303518144126&wfr=spider&for=pc)
* [【简书】執著我們的執著《8. 红黑树与AVL树，各自的优缺点总结》](https://www.jianshu.com/p/37436ed14cc6)
* [【百度百科】红黑树](https://baike.baidu.com/item/%E7%BA%A2%E9%BB%91%E6%A0%91/2413209?fr=aladdin)

---

**不折腾的前端，和咸鱼有什么区别！**

![图](../../../public-repertory/img/z-index-small.png)

**jsliang** 会每天更新一道 LeetCode 题解，从而帮助小伙伴们夯实原生 JS 基础，了解与学习算法与数据结构。

**浪子神剑** 会每天更新面试题，以面试题为驱动来带动大家学习，坚持每天学习与思考，每天进步一点！

扫描上方二维码，关注 **jsliang** 的公众号（左）和 **浪子神剑** 的公众号（右），让我们一起折腾！

> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">jsliang 的文档库</span> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/LiangJunrong/document-library" property="cc:attributionName" rel="cc:attributionURL">梁峻荣</a> 采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。<br />基于<a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/LiangJunrong/document-library" rel="dct:source">https://github.com/LiangJunrong/document-library</a>上的作品创作。<br />本许可协议授权之外的使用权限可以从 <a xmlns:cc="http://creativecommons.org/ns#" href="https://creativecommons.org/licenses/by-nc-sa/2.5/cn/" rel="cc:morePermissions">https://creativecommons.org/licenses/by-nc-sa/2.5/cn/</a> 处获得。