数据结构 - 队列
===

> Create by **jsliang** on **2019-09-05 10:06:42**  
> Recently revised in **2019-11-11 17:21:11**

## <a name="chapter-one" id="chapter-one">一 目录</a>

**不折腾的前端，和咸鱼有什么区别**

| 目录 |
| --- | 
| [一 目录](#chapter-one) | 
| <a name="catalog-chapter-two" id="catalog-chapter-two"></a>[二 前言](#chapter-two) |
| <a name="catalog-chapter-three" id="catalog-chapter-three"></a>[三 模拟实现队列](#chapter-three) |
| <a name="catalog-chapter-four" id="catalog-chapter-four"></a>[四 优先队列](#chapter-four) |
| <a name="catalog-chapter-five" id="catalog-chapter-five"></a>[五 击鼓传花](#chapter-five) |
| <a name="catalog-chapter-six" id="catalog-chapter-six"></a>[六 总结](#chapter-six) |

## <a name="chapter-two" id="chapter-two">二 前言</a>

> [返回目录](#chapter-one)

队列，和栈有点类似，但是又不太一样，队列遵循 **先进先出** 的原则。

假如将前面学过的栈用堆叠的书来比喻，需要一本一本拿，才能拿到最底部的书来说的话。

那么队列就是排队，假如你去银行排队，那么，在前面的人先享受服务，完后前面的人先走。

形象点：

```
入栈：（底部）A<-B<-C<-D（顶部）
出栈：（底部）A->B->C->D（顶部）

入队列：（头部）A<-B<-C<-D（尾部）
出队列：（头部）A<-B<-C<-D（尾部）
```

## <a name="chapter-three" id="chapter-three">三 模拟实现队列</a>

> [返回目录](#chapter-one)

在了解了队列后，我们模拟实现一个队列，加深我们对队列的印象。

**首先**，为栈声明一些方法：

* `push(element)`：添加一个或者多个元素到栈顶
* `pop()`：移除栈顶的元素，同时返回该元素
* `peek()`：查看栈顶的元素
* `isEmpty()`：判断栈是否空了，是则返回 `true`，否则返回 `false`
* `clear()`：清除栈中的所有元素
* `size`：返回栈里的元素个数，方法和 `length` 类似

**然后**，我们尝试实现这些方法：

> 实现代码：

```js
function Queue() {
  const items = [];
  // 1. 元素入队列
  this.enqueue = function(element) {
    items.push(element);
  };
  // 2. 元素出队列
  this.dqueue = function() {
    return items.shift();
  };
  // 3. 查看队列顶部元素
  this.front = function() {
    return items[0];
  };
  // 4. 判断队列是否为空
  this.isEmpty = function() {
    return items.length === 0;
  };
  // 5. 查看整个队列长度
  this.size = function() {
    return items.length;
  };
  // 6. 查看整个队列
  this.print = function() {
    console.log(items);
  }
};

let queue = new Queue();
queue.enqueue('1'); // [ '1' ]
queue.enqueue('2'); // [ '1', '2' ]
queue.dqueue(); // [ '2' ]
queue.dqueue(); // [ ]
queue.print(); // []
```

**最后**，如果纯粹看 **jsliang** 写的，没图没视频，小伙伴们很容易懵逼，这里 **jsliang** 建议看各个大佬的文章或者通过下面章节的几个案例进一步了解：

* [JS中的算法与数据结构——队列(Queue)](https://www.jianshu.com/p/1157aaccad36)
* [使用 JavaScript 实现基本队列、优先队列和循环队列](https://www.cnblogs.com/dee0912/p/4960025.html)

---

**不折腾的前端，和咸鱼有什么区别！**

![图](../../../public-repertory/img/z-small-wechat-public-address.jpg)

**jsliang** 会每天更新一道 LeetCode 题解，从而帮助小伙伴们夯实原生 JS 基础，了解与学习算法与数据结构。

扫描上方二维码，关注 **jsliang** 的公众号，让我们一起折腾！

> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">jsliang 的文档库</span> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/LiangJunrong/document-library" property="cc:attributionName" rel="cc:attributionURL">梁峻荣</a> 采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。<br />基于<a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/LiangJunrong/document-library" rel="dct:source">https://github.com/LiangJunrong/document-library</a>上的作品创作。<br />本许可协议授权之外的使用权限可以从 <a xmlns:cc="http://creativecommons.org/ns#" href="https://creativecommons.org/licenses/by-nc-sa/2.5/cn/" rel="cc:morePermissions">https://creativecommons.org/licenses/by-nc-sa/2.5/cn/</a> 处获得。