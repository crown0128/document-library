浏览器工作原理和实践
===

> Create by **jsliang** on **2020-10-05 15:48:25**  
> Recently revised in **2020-10-05 22:40:25**

<!-- 目录开始 -->
## <a name="chapter-one" id="chapter-one"></a>一 目录

**不折腾的前端，和咸鱼有什么区别**

| 目录 |
| --- |
| [一 目录](#chapter-one) |
| <a name="catalog-chapter-two" id="catalog-chapter-two"></a>[二 前言](#chapter-two) |
| <a name="catalog-chapter-three" id="catalog-chapter-three"></a>[三 一个页面 4 个进程](#chapter-three) |
| &emsp;[3.1 进程和线程](#chapter-three-one) |
| &emsp;[3.2 单进程浏览器](#chapter-three-two) |
| &emsp;[3.3 多进程浏览器](#chapter-three-three) |
| &emsp;[3.4 评论区问题](#chapter-three-four) |
| <a name="catalog-chapter-four" id="catalog-chapter-four"></a>[四 TCP 协议：保证页面文件完整送达浏览器](#chapter-four) |
| &emsp;[4.1 评论区问题](#chapter-four-one) |
| <a name="catalog-chapter-five" id="catalog-chapter-five"></a>[五 HTTP 请求：站点二次打开速度很快](#chapter-five) |
| &emsp;[5.1 HTTP 请求过程](#chapter-five-one) |
| &emsp;[5.2 为什么站点第二次打开速度很快](#chapter-five-two) |
| &emsp;[5.3 登录态如何保持](#chapter-five-three) |
| <a name="catalog-chapter-six" id="catalog-chapter-six"></a>[六 从输入 URL 到页面呈现的过程](#chapter-six) |
| <a name="catalog-chapter-seven" id="catalog-chapter-seven"></a>[七 浏览器渲染过程](#chapter-seven) |
| &emsp;[7.1 DOM 树的构建过程](#chapter-seven-one) |
| &emsp;[7.2 CSS 规则树的构建过程](#chapter-seven-two) |
| &emsp;[7.3 布局](#chapter-seven-three) |
| &emsp;[7.4 小结](#chapter-seven-four) |
| &emsp;[7.5 评论区问题](#chapter-seven-five) |
| <a name="catalog-chapter-eight" id="catalog-chapter-eight"></a>[八 变量提升](#chapter-eight) |
| <a name="catalog-chapter-night" id="catalog-chapter-night"></a>[九 JavaScript 栈溢出](#chapter-night) |
| &emsp;[9.1 函数调用](#chapter-night-one) |
| &emsp;[9.2 栈](#chapter-night-two) |
| &emsp;[9.3 调用栈](#chapter-night-three) |
| &emsp;[9.4 栈溢出](#chapter-night-four) |
| <a name="catalog-chapter-ten" id="catalog-chapter-ten"></a>[十 var 的缺陷和 let、const](#chapter-ten) |
| &emsp;[10.1 作用域](#chapter-ten-one) |
| &emsp;[10.2 题目](#chapter-ten-two) |
| <a name="catalog-chapter-eleven" id="catalog-chapter-eleven"></a>[十一 作用域链和闭包](#chapter-eleven) |
| <a name="catalog-chapter-twelve" id="catalog-chapter-twelve"></a>[十二 参考文献](#chapter-twelve) |
<!-- 目录结束 -->

## <a name="chapter-two" id="chapter-two"></a>二 前言

> [返回目录](#chapter-one)

浏览器 3 个大的进化路线：

* 第一个是应用程序 Web 化。
* 第二个是 Web 应用移动化。
* 第三个是 Web 操作系统化。

为什么要学习浏览器工作原理：

* 准确评估 Web 开发项目的可行性。桌面端、客户端还是其他方式。
* 从更高维度审视页面。输入 URL 到页面呈现，哪些角度优化，如何高效加载。
* 在快节奏的技术迭代中把握本质。Node.js 的推进，前端逐步稳定。

## <a name="chapter-three" id="chapter-three"></a>三 一个页面 4 个进程

> [返回目录](#chapter-one)

Chrome 也有任务管理器的，再标签栏右键可以看到有任务管理器的菜单。点击之后会发现 Chrome 启动了 4 个进程。

### <a name="chapter-three-one" id="chapter-three-one"></a>3.1 进程和线程

> [返回目录](#chapter-one)

已知代码：

```js
A = 1+2
B = 20/5
C = 7*8
```

按 **单线程** 来处理，那就分 4 步走，第一步处理 A，第二步处理 B……第 4 步显示最后计算的结果。

按 **多线程** 来处理，第一步用 3 个线程同时处理前 3 个任务，第二步来执行显示结果。

而 **线程是不能单独存在的，它是由进程来启动和管理的**。

所谓 **进程**，就是启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放 **代码**、运行中的 **数据** 和一个执行任务的 **主线程**。

对于操作系统来说，**一个任务就是一个进程**。打开一个浏览器就是启动一个浏览器进程，打开一个记事本就是启动一个记事本进程，打开两个记事本就是启动了 2 个记事本进。

我们把 **进程中的子任务称为线程**。就好比浏览器中有浏览器主进程、GPU 进程、网络进程、渲染进程等。渲染进程就负责将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页。

进程和线程之间的关系：

1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。如果 `B = 20 / 0`，那么导致这一线程报错，从而整个进程崩溃。
2. 线程之间共享进程中的数据。在多线程处理中，第二步骤可以调取第一步骤存放到数据中的内容。
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。就好比浏览器开着，内存占用越来越多，从而导致操作卡顿。但是当浏览器关闭之后，这些内存都会被系统回收调。
4. 进程之间的内容相互隔离。如果 A 页面崩溃了，B 页面不会受此影响；A 页面的数据也不会串入 B 页面中。

### <a name="chapter-three-two" id="chapter-three-two"></a>3.2 单进程浏览器

> [返回目录](#chapter-one)

早在 2007 年之前，市面上的浏览器都是单进程的。

单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。

这样就会有诸多问题：

1. **不稳定**。某个音频、视频插件出了问题，整个页面就崩溃了，整个浏览器崩溃了；JavaScript 过于复杂，渲染引擎模块崩了，整个浏览器崩溃了。
2. **不流畅**。同一时刻只能有一个模块执行，在 JavaScript 写了个死循环，结果整个浏览器就失去响应，变卡顿。
3. **不安全**。如果你安装了某个插件，然后页面运行这个插件就意味着插件操作你的代码。

### <a name="chapter-three-three" id="chapter-three-three"></a>3.3 多进程浏览器

> [返回目录](#chapter-one)

1. 解决不稳定问题。一个页面崩溃不会导致整个浏览器崩溃。
2. 解决不流畅问题。JavaScript 死循环也就影响当前页面。
3. 解决不安全问题。渲染进程不能读取硬盘的数据和获取操作系统权限。

最新的 Chrome 浏览器包括：

* 1 个浏览器主进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
* 1 个 GPU 进程：实现 3D CSS 的效果，网页、Chrome 的 UI 页面绘制。
* 1 个网络进程：主要负责页面的网络资源加载。
* 多个渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页
* 多个插件进程

其中渲染进程负责 解析、渲染、JavaScript 执行、合成网页图片。

渲染进程运行在沙箱里面，不能读写硬盘上的数据，不能获取操作系统权限。

这时候就可以呼应本章开头，一个页面 4 个进程即打开 1 个页面，至少有 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及一个渲染进程。如果有插件运行，还需要假设插件进程。

缺陷：

* 更高的资源占用。存储多了，消耗更多的内存资源。
* 更复杂的体系架构。各个模块之间的耦合性、扩展性等。

### <a name="chapter-three-four" id="chapter-three-four"></a>3.4 评论区问题

> [返回目录](#chapter-one)

* 问：偶尔还会碰到一些由于单个页面卡死最终崩溃导致所有页面崩溃的情况，请问这是什么原因？
* 答：

通常情况下是一个页面使用一个进程，但是，有一种情况，叫 “同一站点(same-site)”。

具体地讲，我们将 “同一站点” 定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口。

这块和同源策略稍微有点不同。

```
https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080
```

这 3 个都是同一站点，因为协议都是 `https`，根域名都是 `geekband.org`。

Chrome 有个策略，就是当你从 A 标签中打开新页面 B，而新页面 B 和 A 页面属于同一个站点，那么新页面 B 就复用页面 A 的渲染过程。

这种情况下， B 页面崩溃了，会导致 A 页面同时崩溃，因为使用了同一个渲染过程。

## <a name="chapter-four" id="chapter-four"></a>四 TCP 协议：保证页面文件完整送达浏览器

> [返回目录](#chapter-one)

在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中又有很大概率丢失或者出错。那么如何保证页面文件能被完整地送达浏览器呢？

1. 互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。
2. IP 负责把数据包送达目的主机。
3. UDP 负责把数据包送达具体应用。
4. TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。

### <a name="chapter-four-one" id="chapter-four-one"></a>4.1 评论区问题

> [返回目录](#chapter-one)

* **如何理解 HTTP 和 TCP 的关系？**

HTTP 协议和 TCP 协议都是 TCP/IP 协议簇的子集。

HTTP 协议属于应用层，TCP 协议属于传输层，HTTP 协议位于 TCP 协议的上层。

请求方要发送的数据包，在应用层加上 HTTP 头以后会交给传输层的 TCP协议处理，应答方接收到的数据包，在传输层拆掉 TCP头 以后交给应用层的 HTTP 协议处理。

建立 TCP 连接后会顺序收发数据，请求方和应答方都必须依据 HTTP 规范构建和解析 HTTP 报文。

* **浏览器同时打开多个相同标签，数据怎么传达具体页签？**

网络进程知道每个 TCP 链接所对应的标签，所以接收数据后，会把数据分发给对应的渲染进程。

## <a name="chapter-five" id="chapter-five"></a>五 HTTP 请求：站点二次打开速度很快

> [返回目录](#chapter-one)

HTTP 协议，是建立在 TCP 连接基础之上的。

HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。

HTTP 是浏览器使用最广的协议。

### <a name="chapter-five-one" id="chapter-five-one"></a>5.1 HTTP 请求过程

> [返回目录](#chapter-one)

对于网站：`http://time.geekbang.org/index.html`

1. 构建请求。`GET / index.html HTTP1.1`
2. 查找缓存。判断浏览器是否进行强缓存或者协商缓存。[浏览器 - 浏览器缓存](https://github.com/LiangJunrong/document-library/blob/master/other-library/interview/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98.md)
3. 准备 IP 地址和端口。浏览器请求第一步是和服务器建立 TCP 连接，而建立 TCP 连接需要准备 IP 地址和端口号，那就好通过 DNS 解析获取端口号了。[计算机网络 - DNS](https://github.com/LiangJunrong/document-library/blob/master/other-library/interview/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS.md)
4. 等待 TCP 队列。同一个域名最多只能建立 6 个 TCP 连接。所以如果有 10 个请求，那么有 4 个会进入等待状态；如果少于 6 个进入下一步。
5. 建立 TCP 连接。[计算机网络 - TCP](https://github.com/LiangJunrong/document-library/blob/master/other-library/interview/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP.md)。
6. 发送 HTTP 请求。HTTP 请求报文由 3 部分组成：**请求行**、**请求报头** 和 **请求正文**。
7. 服务端处理 HTTP 请求。HTTP 响应报文由 3 部分组成：**状态码**、**响应报头** 和 **响应报文**。
8. 断开 TCP 连接。如果浏览器或者服务器的头信息加入了 `Connection: Keep-Alive`，那 TCP 连接会保持打开状态，浏览器可以通过同一个 TCP 连接持续发送请求。否则则会中断。

### <a name="chapter-five-two" id="chapter-five-two"></a>5.2 为什么站点第二次打开速度很快

> [返回目录](#chapter-one)

浏览器缓存：

* DNS 缓存
* 页面资源缓存

### <a name="chapter-five-three" id="chapter-five-three"></a>5.3 登录态如何保持

> [返回目录](#chapter-one)

登录态：用户的登录状态，用来标识这个用户的身份。

* `Cookie` 登录态实现

如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。

当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。

服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。

* 其他实现方案

1. 存储型。根据 `token` 去服务端存储上查找用户信息，查找不到就校验失败，反之成功。
2. 计算型。将用户信息（`userId`）加密成字符串，这个字符串就是 `token`，服务端解析用户传递过来的 `userId + generateTimestamp` 来判断是否过期。
3. 全自动登录。用户登录过一次后，保存登录态，避免每次执行用例都调用登录接口，无需手动登录。

## <a name="chapter-six" id="chapter-six"></a>六 从输入 URL 到页面呈现的过程

> [返回目录](#chapter-one)

省略。

## <a name="chapter-seven" id="chapter-seven"></a>七 浏览器渲染过程

> [返回目录](#chapter-one)

### <a name="chapter-seven-one" id="chapter-seven-one"></a>7.1 DOM 树的构建过程

> [返回目录](#chapter-one)

为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。

在 Chrome 控制台 Console 模块，输入 `document` 就可以看到完整的 DOM 树结构。

可以通过 JavaScript 来修改 DOM：

```js
document.getElementsByTagName("p")[0].innerText = "black"
```

这行代码会把第一个 `<p>` 标签的内容修改为 `black`。

### <a name="chapter-seven-two" id="chapter-seven-two"></a>7.2 CSS 规则树的构建过程

> [返回目录](#chapter-one)

**首先**，CSS 样式来源主要有三种：通过 link 引用的外部 CSS 文件

* 通过 `link` 引用的外部 CSS 文件
* `<style>` 标记内的 CSS
* 元素的 `style` 属性内嵌的 CSS

和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。

在 Chrome 控制台 Console 模块，输入 `document.styleSheets` 就可以看到完整的 CSS 规则树。

**然后**，一些属性值需要进行标准化操作：

```css
body { font-size: 2em; }
p { color: blue; }
```

这个就会变成：

```css
body { font-size: 32px; }
p { color: rgb(0, 0, 255) }
```

这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

**最后**，计算 DOM 树中每个节点的具体位置

这涉及到 CSS 的继承规则和层叠规则。

* CSS 继承：每个 DOM 节点都包含有父节点的样式。在 Chrome 的 Elements 模块可以看到某个标签不仅仅有当前标签，还继承 `body`、`html` 等的属性。
* CSS 层叠：合并来自多个源的属性值。

### <a name="chapter-seven-three" id="chapter-seven-three"></a>7.3 布局

> [返回目录](#chapter-one)

接下来需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。

1. 创建布局树
2. 布局计算

### <a name="chapter-seven-four" id="chapter-seven-four"></a>7.4 小结

> [返回目录](#chapter-one)

一个完整的渲染流程大致可总结为如下：

* 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
* 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
* 创建布局树，并计算元素的布局信息。
* 对布局树进行分层，并生成分层树。
* 为每个图层生成绘制列表，并将其提交到合成线程。
* 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
* 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
* 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

### <a name="chapter-seven-five" id="chapter-seven-five"></a>7.5 评论区问题

> [返回目录](#chapter-one)

* **下载 CSS 文件阻塞，会阻塞 DOM 树的合成吗？**

当从服务器接收 HTML 页面的第一批数据时，DOM 解析器就开始工作了，在解析过程中，如果遇到了JS脚本，如下所示：

```html
<html>
  <body>
    jsliang
    <script>
      document.write("--foo")
    </script>
  </body>
</html>
```

那么 DOM 解析器会先执行 JavaScript 脚本，执行完成之后，再继续往下解析。

那么第二种情况复杂点了，我们内联的脚本替换成js外部文件，如下所示：

```html
<html>
  <body>
    jsliang
    <script type="text/javascript" src="foo.js"></script>
  </body>
</html>
```

这种情况下，当解析到 JavaScript 的时候，会先暂停 DOM 解析，并下载 `foo.js` 文件，下载完成之后执行该段 JS 文件，然后再继续往下解析 DOM。这就是 JavaScript 文件为什么会阻塞 DOM 渲染。

我们再看第三种情况，还是看下面代码：

```html
<html>
  <head>
    <style type="text/css" src = "theme.css" />
  </head>
  <body>
    <p>jsliang</p>
    <script>
      let e = document.getElementsByTagName('p')[0]
      e.style.color = 'blue'
    </script>
  </body>
</html>
```

当我在 JavaScript 中访问了某个元素的样式，那么这时候就需要等待这个样式被下载完成才能继续往下执行，所以在这种情况下，CSS 也会阻塞 DOM 的解析。

所以 JS 和 CSS 都有可能会阻塞 DOM 解析。

## <a name="chapter-eight" id="chapter-eight"></a>八 变量提升

> [返回目录](#chapter-one)

只有理解了 JavaScrip 的执行上下文，你才能更好地理解 JavaScript 语言本身，比如变量提升、作用域和闭包等。

```js
showName();
console.log(myname);
var myname = 'jsliang';
function showName() {
  console.log('函数 showName 被执行');
}
```

按道理来说，我们的 `console` 先于 `var myname` 定义，打印 `console` 应该会报错。

但是实际上打印的是 `undefined`。

同样，`showName()` 函数是后面定义的，按道理也会报错，实际上会打印  `函数 showName 被执行`。

这个就是变量提升。

从浏览器工作原理上看，这段代码会变成：

```diff
+ // 函数声明前置
+ function showName() {
+  console.log('函数 showName 被执行');
+ }
+ var myname; // 声明部分 - undefined
showName();
console.log(myname);
+ name = 'jsliang'; // 赋值部分
- var myname = 'jsliang';
- function showName() {
-  console.log('函数 showName 被执行');
- }
```

所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的 “行为”。

变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 `undefined`。

既然如此，那么下面代码输出什么？

```js
showName();
var showName = function() {
  console.log(2);
}
function showName() {
  console.log(1);
}
```

答案：1

变量提升会产生什么问题：

1. 变量容易在不被察觉的情况下被覆盖掉
2. 本应销毁的变量没有被销毁

## <a name="chapter-night" id="chapter-night"></a>九 JavaScript 栈溢出

> [返回目录](#chapter-one)

JavaScript 中有很多函数，经常会出现在一个函数中调用另外一个函数的情况，调用栈就是用来管理函数调用关系的一种数据结构。

### <a name="chapter-night-one" id="chapter-night-one"></a>9.1 函数调用

> [返回目录](#chapter-one)

```js
var a = 2;

function add() {
  var b = 10;
  return a + b;
}

add();
```

在这段代码中，首先创建 `add` 函数，然后调用该函数，进行求和。

| 全局执行上下文 |  |
| --- | --- |
| 变量环境 | 词法环境 |
| a = undefined |  |
| add = function () { ... } |  |

### <a name="chapter-night-two" id="chapter-night-two"></a>9.2 栈

> [返回目录](#chapter-one)

后进先出，简单来说，一个数组：

```js
var a = [];
a.push(1);
a.push(2);
a.push(3);
console.log(a); // [1, 2, 3]
```

这个步骤叫压栈，就是将数字不停地塞进数组尾部。

```js
a.pop(); // 3
a.pop(); // 2
a.pop(); // 1
console.log(a); []
```

这个步骤叫出栈，就是将数字不停地从数组尾部取出。

栈就类似于叠罗汉，压栈就是先叠第一层，再叠第二层……出栈就是先出最高那层，再出倒数第二层……

### <a name="chapter-night-three" id="chapter-night-three"></a>9.3 调用栈

> [返回目录](#chapter-one)

JavaScript 引擎就是利用栈这种结构管理执行上下文的。

在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。

我们拿一个递归函数来看：

```js
const recursion = (num) => {
  if (num === 1) {
    return 1;
  }
  recursion(num - 1);
};
recursion(3);
```

在这里，先执行 `recursion(3)`，再执行 `recursion(2)`，最后执行 `recursion(1)`，这是压栈步骤。

接着 `recursion(1)` 执行完毕，消除这个；`recursion(2)` 执行完毕，最后 `recursion(3)` 执行完毕。

这种机制就是调用栈。

### <a name="chapter-night-four" id="chapter-night-four"></a>9.4 栈溢出

> [返回目录](#chapter-one)

假如这时候，我们将代码变一变：

```js
const recursion = (num) => {
  if (num === 1) {
    return 1;
  }
  if (num === 2) {
    return 2;
  }
  return recursion(num - 1) + recursion(num - 2);
};
console.log(recursion(100));
```

JavaScript 的调用栈是有大小的，入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，这种错误就是栈溢出。

**jsliang** 运行上面这行代码，放了一会手提就疯狂运转了！

所以有时候看到：超过了最大栈调用大小（Maximum call stack size exceeded），你应该知道是什么问题了。

## <a name="chapter-ten" id="chapter-ten"></a>十 var 的缺陷和 let、const

> [返回目录](#chapter-one)

由于 JavaScript 存在变量提升这种特性，从而导致了很多与直觉不符的代码，这也是 JavaScript 的一个重要设计缺陷。

虽然 ECMAScript6（以下简称 ES6）已经通过引入块级作用域并配合 `let`、`const `关键字，来避开了这种设计缺陷，但是由于 JavaScript 需要保持向下兼容，所以变量提升在相当长一段时间内还会继续存在。

### <a name="chapter-ten-one" id="chapter-ten-one"></a>10.1 作用域

> [返回目录](#chapter-one)

作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

ES5 时候的作用域只有两种：

* **全局作用域**：全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
* **函数作用域**：函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

ES6 有块级作用域的定义：

* **块级作用域**：使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个 `{}` 都可以被看作是一个块级作用域。

```js
// if块
if(1){}

// while 块
while(1){}

// 函数块
function foo(){}
 
// for 循环块
for(let i = 0; i<100; i++){}

// 单独一个块
{}
```

块级作用域其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。

### <a name="chapter-ten-two" id="chapter-ten-two"></a>10.2 题目

> [返回目录](#chapter-one)

```js
function foo(){
  var a = 1;
  let b = 2;
  {
    let b = 3;
    var c = 4;
    let d = 5;
    console.log(a);
    console.log(b);
  }
  console.log(b);
  console.log(c);
  console.log(d);
}   
foo();
```

求打印顺序。

答：1 -> 3 -> 2 -> 4 -> 报错

## <a name="chapter-eleven" id="chapter-eleven"></a>十一 作用域链和闭包

> [返回目录](#chapter-one)

未完待续。

## <a name="chapter-twelve" id="chapter-twelve"></a>十二 参考文献

> [返回目录](#chapter-one)

* [ ] [极客时间 - 浏览器工作原理与实践](https://time.geekbang.org/column/intro/100033601)【阅读建议：3.5h+】
* [x] [廖雪峰 - 进程和线程](https://www.liaoxuefeng.com/wiki/1016959663602400/1017627212385376)【阅读建议：10min】

---

> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">jsliang 的文档库</span> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/LiangJunrong/document-library" property="cc:attributionName" rel="cc:attributionURL">梁峻荣</a> 采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。<br />基于<a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/LiangJunrong/document-library" rel="dct:source">https://github.com/LiangJunrong/document-library</a>上的作品创作。<br />本许可协议授权之外的使用权限可以从 <a xmlns:cc="http://creativecommons.org/ns#" href="https://creativecommons.org/licenses/by-nc-sa/2.5/cn/" rel="cc:morePermissions">https://creativecommons.org/licenses/by-nc-sa/2.5/cn/</a> 处获得。