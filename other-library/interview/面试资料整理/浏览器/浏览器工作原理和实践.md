浏览器工作原理和实践
===

> Create by **jsliang** on **2020-10-05 15:48:25**  
> Recently revised in **2020-10-05 22:40:25**

<!-- 目录开始 -->
## <a name="chapter-one" id="chapter-one"></a>一 目录

**不折腾的前端，和咸鱼有什么区别**

| 目录 |
| --- |
| [一 目录](#chapter-one) |
| <a name="catalog-chapter-two" id="catalog-chapter-two"></a>[二 前言](#chapter-two) |
| <a name="catalog-chapter-three" id="catalog-chapter-three"></a>[三 一个页面 4 个进程](#chapter-three) |
| &emsp;[3.1 进程和线程](#chapter-three-one) |
| &emsp;[3.2 单进程浏览器](#chapter-three-two) |
| &emsp;[3.3 多进程浏览器](#chapter-three-three) |
| &emsp;[3.4 评论区问题](#chapter-three-four) |
| <a name="catalog-chapter-four" id="catalog-chapter-four"></a>[四 TCP 协议：保证页面文件完整送达浏览器](#chapter-four) |
| &emsp;[4.1 评论区问题](#chapter-four-one) |
| <a name="catalog-chapter-five" id="catalog-chapter-five"></a>[五 HTTP 请求：站点二次打开速度很快](#chapter-five) |
| &emsp;[5.1 HTTP 请求过程](#chapter-five-one) |
| &emsp;[5.2 为什么站点第二次打开速度很快](#chapter-five-two) |
| &emsp;[5.3 登录态如何保持](#chapter-five-three) |
| <a name="catalog-chapter-six" id="catalog-chapter-six"></a>[六 从输入 URL 到页面呈现的过程](#chapter-six) |
| <a name="catalog-chapter-seven" id="catalog-chapter-seven"></a>[七 浏览器渲染过程](#chapter-seven) |
| &emsp;[7.1 DOM 树的构建过程](#chapter-seven-one) |
| &emsp;[7.2 CSS 规则树的构建过程](#chapter-seven-two) |
| &emsp;[7.3 布局](#chapter-seven-three) |
| &emsp;[7.4 小结](#chapter-seven-four) |
| &emsp;[7.5 评论区问题](#chapter-seven-five) |
| <a name="catalog-chapter-eight" id="catalog-chapter-eight"></a>[八 变量提升](#chapter-eight) |
| <a name="catalog-chapter-night" id="catalog-chapter-night"></a>[九 JavaScript 栈溢出](#chapter-night) |
| &emsp;[9.1 函数调用](#chapter-night-one) |
| &emsp;[9.2 栈](#chapter-night-two) |
| &emsp;[9.3 调用栈](#chapter-night-three) |
| &emsp;[9.4 栈溢出](#chapter-night-four) |
| <a name="catalog-chapter-ten" id="catalog-chapter-ten"></a>[十 var 的缺陷和 let、const](#chapter-ten) |
| &emsp;[10.1 作用域](#chapter-ten-one) |
| &emsp;[10.2 题目](#chapter-ten-two) |
| <a name="catalog-chapter-eleven" id="catalog-chapter-eleven"></a>[十一 作用域链和闭包](#chapter-eleven) |
| &emsp;[11.1 作用域链和词法作用域](#chapter-eleven-one) |
| &emsp;[11.2 块级作用域](#chapter-eleven-two) |
| &emsp;[11.3 闭包](#chapter-eleven-three) |
| &emsp;[11.4 如何回收闭包](#chapter-eleven-four) |
| &emsp;[11.5 小结](#chapter-eleven-five) |
| <a name="catalog-chapter-twelve" id="catalog-chapter-twelve"></a>[十二 this](#chapter-twelve) |
| &emsp;[12.1 全局执行上下文中的 this](#chapter-twelve-one) |
| &emsp;[12.2 函数执行上下文中的 this](#chapter-twelve-two) |
| &emsp;&emsp;[12.2.1 通过 call/bind/apply 改变 this](#chapter-twelve-two-one) |
| &emsp;&emsp;[12.2.2 通过对象调用方法设置](#chapter-twelve-two-two) |
| &emsp;&emsp;[12.2.3 通过构造函数中设置](#chapter-twelve-two-three) |
| &emsp;[12.3 this 设计缺陷和应对方案](#chapter-twelve-three) |
| &emsp;[12.4 小结](#chapter-twelve-four) |
| <a name="catalog-chapter-thirteen" id="catalog-chapter-thirteen"></a>[十三 参考文献](#chapter-thirteen) |
<!-- 目录结束 -->

## <a name="chapter-two" id="chapter-two"></a>二 前言

> [返回目录](#chapter-one)

浏览器 3 个大的进化路线：

* 第一个是应用程序 Web 化。
* 第二个是 Web 应用移动化。
* 第三个是 Web 操作系统化。

为什么要学习浏览器工作原理：

* 准确评估 Web 开发项目的可行性。桌面端、客户端还是其他方式。
* 从更高维度审视页面。输入 URL 到页面呈现，哪些角度优化，如何高效加载。
* 在快节奏的技术迭代中把握本质。Node.js 的推进，前端逐步稳定。

## <a name="chapter-three" id="chapter-three"></a>三 一个页面 4 个进程

> [返回目录](#chapter-one)

Chrome 也有任务管理器的，再标签栏右键可以看到有任务管理器的菜单。点击之后会发现 Chrome 启动了 4 个进程。

### <a name="chapter-three-one" id="chapter-three-one"></a>3.1 进程和线程

> [返回目录](#chapter-one)

已知代码：

```js
A = 1+2
B = 20/5
C = 7*8
```

按 **单线程** 来处理，那就分 4 步走，第一步处理 A，第二步处理 B……第 4 步显示最后计算的结果。

按 **多线程** 来处理，第一步用 3 个线程同时处理前 3 个任务，第二步来执行显示结果。

而 **线程是不能单独存在的，它是由进程来启动和管理的**。

所谓 **进程**，就是启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放 **代码**、运行中的 **数据** 和一个执行任务的 **主线程**。

对于操作系统来说，**一个任务就是一个进程**。打开一个浏览器就是启动一个浏览器进程，打开一个记事本就是启动一个记事本进程，打开两个记事本就是启动了 2 个记事本进。

我们把 **进程中的子任务称为线程**。就好比浏览器中有浏览器主进程、GPU 进程、网络进程、渲染进程等。渲染进程就负责将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页。

进程和线程之间的关系：

1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。如果 `B = 20 / 0`，那么导致这一线程报错，从而整个进程崩溃。
2. 线程之间共享进程中的数据。在多线程处理中，第二步骤可以调取第一步骤存放到数据中的内容。
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。就好比浏览器开着，内存占用越来越多，从而导致操作卡顿。但是当浏览器关闭之后，这些内存都会被系统回收调。
4. 进程之间的内容相互隔离。如果 A 页面崩溃了，B 页面不会受此影响；A 页面的数据也不会串入 B 页面中。

### <a name="chapter-three-two" id="chapter-three-two"></a>3.2 单进程浏览器

> [返回目录](#chapter-one)

早在 2007 年之前，市面上的浏览器都是单进程的。

单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。

这样就会有诸多问题：

1. **不稳定**。某个音频、视频插件出了问题，整个页面就崩溃了，整个浏览器崩溃了；JavaScript 过于复杂，渲染引擎模块崩了，整个浏览器崩溃了。
2. **不流畅**。同一时刻只能有一个模块执行，在 JavaScript 写了个死循环，结果整个浏览器就失去响应，变卡顿。
3. **不安全**。如果你安装了某个插件，然后页面运行这个插件就意味着插件操作你的代码。

### <a name="chapter-three-three" id="chapter-three-three"></a>3.3 多进程浏览器

> [返回目录](#chapter-one)

1. 解决不稳定问题。一个页面崩溃不会导致整个浏览器崩溃。
2. 解决不流畅问题。JavaScript 死循环也就影响当前页面。
3. 解决不安全问题。渲染进程不能读取硬盘的数据和获取操作系统权限。

最新的 Chrome 浏览器包括：

* 1 个浏览器主进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
* 1 个 GPU 进程：实现 3D CSS 的效果，网页、Chrome 的 UI 页面绘制。
* 1 个网络进程：主要负责页面的网络资源加载。
* 多个渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页
* 多个插件进程

其中渲染进程负责 解析、渲染、JavaScript 执行、合成网页图片。

渲染进程运行在沙箱里面，不能读写硬盘上的数据，不能获取操作系统权限。

这时候就可以呼应本章开头，一个页面 4 个进程即打开 1 个页面，至少有 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及一个渲染进程。如果有插件运行，还需要假设插件进程。

缺陷：

* 更高的资源占用。存储多了，消耗更多的内存资源。
* 更复杂的体系架构。各个模块之间的耦合性、扩展性等。

### <a name="chapter-three-four" id="chapter-three-four"></a>3.4 评论区问题

> [返回目录](#chapter-one)

* 问：偶尔还会碰到一些由于单个页面卡死最终崩溃导致所有页面崩溃的情况，请问这是什么原因？
* 答：

通常情况下是一个页面使用一个进程，但是，有一种情况，叫 “同一站点(same-site)”。

具体地讲，我们将 “同一站点” 定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口。

这块和同源策略稍微有点不同。

```
https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080
```

这 3 个都是同一站点，因为协议都是 `https`，根域名都是 `geekband.org`。

Chrome 有个策略，就是当你从 A 标签中打开新页面 B，而新页面 B 和 A 页面属于同一个站点，那么新页面 B 就复用页面 A 的渲染过程。

这种情况下， B 页面崩溃了，会导致 A 页面同时崩溃，因为使用了同一个渲染过程。

## <a name="chapter-four" id="chapter-four"></a>四 TCP 协议：保证页面文件完整送达浏览器

> [返回目录](#chapter-one)

在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中又有很大概率丢失或者出错。那么如何保证页面文件能被完整地送达浏览器呢？

1. 互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。
2. IP 负责把数据包送达目的主机。
3. UDP 负责把数据包送达具体应用。
4. TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。

### <a name="chapter-four-one" id="chapter-four-one"></a>4.1 评论区问题

> [返回目录](#chapter-one)

* **如何理解 HTTP 和 TCP 的关系？**

HTTP 协议和 TCP 协议都是 TCP/IP 协议簇的子集。

HTTP 协议属于应用层，TCP 协议属于传输层，HTTP 协议位于 TCP 协议的上层。

请求方要发送的数据包，在应用层加上 HTTP 头以后会交给传输层的 TCP协议处理，应答方接收到的数据包，在传输层拆掉 TCP头 以后交给应用层的 HTTP 协议处理。

建立 TCP 连接后会顺序收发数据，请求方和应答方都必须依据 HTTP 规范构建和解析 HTTP 报文。

* **浏览器同时打开多个相同标签，数据怎么传达具体页签？**

网络进程知道每个 TCP 链接所对应的标签，所以接收数据后，会把数据分发给对应的渲染进程。

## <a name="chapter-five" id="chapter-five"></a>五 HTTP 请求：站点二次打开速度很快

> [返回目录](#chapter-one)

HTTP 协议，是建立在 TCP 连接基础之上的。

HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。

HTTP 是浏览器使用最广的协议。

### <a name="chapter-five-one" id="chapter-five-one"></a>5.1 HTTP 请求过程

> [返回目录](#chapter-one)

对于网站：`http://time.geekbang.org/index.html`

1. 构建请求。`GET / index.html HTTP1.1`
2. 查找缓存。判断浏览器是否进行强缓存或者协商缓存。[浏览器 - 浏览器缓存](https://github.com/LiangJunrong/document-library/blob/master/other-library/interview/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98.md)
3. 准备 IP 地址和端口。浏览器请求第一步是和服务器建立 TCP 连接，而建立 TCP 连接需要准备 IP 地址和端口号，那就好通过 DNS 解析获取端口号了。[计算机网络 - DNS](https://github.com/LiangJunrong/document-library/blob/master/other-library/interview/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS.md)
4. 等待 TCP 队列。同一个域名最多只能建立 6 个 TCP 连接。所以如果有 10 个请求，那么有 4 个会进入等待状态；如果少于 6 个进入下一步。
5. 建立 TCP 连接。[计算机网络 - TCP](https://github.com/LiangJunrong/document-library/blob/master/other-library/interview/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP.md)。
6. 发送 HTTP 请求。HTTP 请求报文由 3 部分组成：**请求行**、**请求报头** 和 **请求正文**。
7. 服务端处理 HTTP 请求。HTTP 响应报文由 3 部分组成：**状态码**、**响应报头** 和 **响应报文**。
8. 断开 TCP 连接。如果浏览器或者服务器的头信息加入了 `Connection: Keep-Alive`，那 TCP 连接会保持打开状态，浏览器可以通过同一个 TCP 连接持续发送请求。否则则会中断。

### <a name="chapter-five-two" id="chapter-five-two"></a>5.2 为什么站点第二次打开速度很快

> [返回目录](#chapter-one)

浏览器缓存：

* DNS 缓存
* 页面资源缓存

### <a name="chapter-five-three" id="chapter-five-three"></a>5.3 登录态如何保持

> [返回目录](#chapter-one)

登录态：用户的登录状态，用来标识这个用户的身份。

* `Cookie` 登录态实现

如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。

当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。

服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。

* 其他实现方案

1. 存储型。根据 `token` 去服务端存储上查找用户信息，查找不到就校验失败，反之成功。
2. 计算型。将用户信息（`userId`）加密成字符串，这个字符串就是 `token`，服务端解析用户传递过来的 `userId + generateTimestamp` 来判断是否过期。
3. 全自动登录。用户登录过一次后，保存登录态，避免每次执行用例都调用登录接口，无需手动登录。

## <a name="chapter-six" id="chapter-six"></a>六 从输入 URL 到页面呈现的过程

> [返回目录](#chapter-one)

省略。

## <a name="chapter-seven" id="chapter-seven"></a>七 浏览器渲染过程

> [返回目录](#chapter-one)

### <a name="chapter-seven-one" id="chapter-seven-one"></a>7.1 DOM 树的构建过程

> [返回目录](#chapter-one)

为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。

在 Chrome 控制台 Console 模块，输入 `document` 就可以看到完整的 DOM 树结构。

可以通过 JavaScript 来修改 DOM：

```js
document.getElementsByTagName("p")[0].innerText = "black"
```

这行代码会把第一个 `<p>` 标签的内容修改为 `black`。

### <a name="chapter-seven-two" id="chapter-seven-two"></a>7.2 CSS 规则树的构建过程

> [返回目录](#chapter-one)

**首先**，CSS 样式来源主要有三种：通过 link 引用的外部 CSS 文件

* 通过 `link` 引用的外部 CSS 文件
* `<style>` 标记内的 CSS
* 元素的 `style` 属性内嵌的 CSS

和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。

在 Chrome 控制台 Console 模块，输入 `document.styleSheets` 就可以看到完整的 CSS 规则树。

**然后**，一些属性值需要进行标准化操作：

```css
body { font-size: 2em; }
p { color: blue; }
```

这个就会变成：

```css
body { font-size: 32px; }
p { color: rgb(0, 0, 255) }
```

这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

**最后**，计算 DOM 树中每个节点的具体位置

这涉及到 CSS 的继承规则和层叠规则。

* CSS 继承：每个 DOM 节点都包含有父节点的样式。在 Chrome 的 Elements 模块可以看到某个标签不仅仅有当前标签，还继承 `body`、`html` 等的属性。
* CSS 层叠：合并来自多个源的属性值。

### <a name="chapter-seven-three" id="chapter-seven-three"></a>7.3 布局

> [返回目录](#chapter-one)

接下来需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。

1. 创建布局树
2. 布局计算

### <a name="chapter-seven-four" id="chapter-seven-four"></a>7.4 小结

> [返回目录](#chapter-one)

一个完整的渲染流程大致可总结为如下：

* 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
* 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
* 创建布局树，并计算元素的布局信息。
* 对布局树进行分层，并生成分层树。
* 为每个图层生成绘制列表，并将其提交到合成线程。
* 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
* 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
* 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

### <a name="chapter-seven-five" id="chapter-seven-five"></a>7.5 评论区问题

> [返回目录](#chapter-one)

* **下载 CSS 文件阻塞，会阻塞 DOM 树的合成吗？**

当从服务器接收 HTML 页面的第一批数据时，DOM 解析器就开始工作了，在解析过程中，如果遇到了JS脚本，如下所示：

```html
<html>
  <body>
    jsliang
    <script>
      document.write("--foo")
    </script>
  </body>
</html>
```

那么 DOM 解析器会先执行 JavaScript 脚本，执行完成之后，再继续往下解析。

那么第二种情况复杂点了，我们内联的脚本替换成js外部文件，如下所示：

```html
<html>
  <body>
    jsliang
    <script type="text/javascript" src="foo.js"></script>
  </body>
</html>
```

这种情况下，当解析到 JavaScript 的时候，会先暂停 DOM 解析，并下载 `foo.js` 文件，下载完成之后执行该段 JS 文件，然后再继续往下解析 DOM。这就是 JavaScript 文件为什么会阻塞 DOM 渲染。

我们再看第三种情况，还是看下面代码：

```html
<html>
  <head>
    <style type="text/css" src = "theme.css" />
  </head>
  <body>
    <p>jsliang</p>
    <script>
      let e = document.getElementsByTagName('p')[0]
      e.style.color = 'blue'
    </script>
  </body>
</html>
```

当我在 JavaScript 中访问了某个元素的样式，那么这时候就需要等待这个样式被下载完成才能继续往下执行，所以在这种情况下，CSS 也会阻塞 DOM 的解析。

所以 JS 和 CSS 都有可能会阻塞 DOM 解析。

## <a name="chapter-eight" id="chapter-eight"></a>八 变量提升

> [返回目录](#chapter-one)

只有理解了 JavaScrip 的执行上下文，你才能更好地理解 JavaScript 语言本身，比如变量提升、作用域和闭包等。

```js
showName();
console.log(myname);
var myname = 'jsliang';
function showName() {
  console.log('函数 showName 被执行');
}
```

按道理来说，我们的 `console` 先于 `var myname` 定义，打印 `console` 应该会报错。

但是实际上打印的是 `undefined`。

同样，`showName()` 函数是后面定义的，按道理也会报错，实际上会打印  `函数 showName 被执行`。

这个就是变量提升。

从浏览器工作原理上看，这段代码会变成：

```diff
+ // 函数声明前置
+ function showName() {
+  console.log('函数 showName 被执行');
+ }
+ var myname; // 声明部分 - undefined
showName();
console.log(myname);
+ name = 'jsliang'; // 赋值部分
- var myname = 'jsliang';
- function showName() {
-  console.log('函数 showName 被执行');
- }
```

所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的 “行为”。

变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 `undefined`。

既然如此，那么下面代码输出什么？

```js
showName();
var showName = function() {
  console.log(2);
}
function showName() {
  console.log(1);
}
```

答案：1

变量提升会产生什么问题：

1. 变量容易在不被察觉的情况下被覆盖掉
2. 本应销毁的变量没有被销毁

## <a name="chapter-night" id="chapter-night"></a>九 JavaScript 栈溢出

> [返回目录](#chapter-one)

JavaScript 中有很多函数，经常会出现在一个函数中调用另外一个函数的情况，调用栈就是用来管理函数调用关系的一种数据结构。

### <a name="chapter-night-one" id="chapter-night-one"></a>9.1 函数调用

> [返回目录](#chapter-one)

```js
var a = 2;

function add() {
  var b = 10;
  return a + b;
}

add();
```

在这段代码中，首先创建 `add` 函数，然后调用该函数，进行求和。

| 全局执行上下文 |  |
| --- | --- |
| 变量环境 | 词法环境 |
| a = undefined |  |
| add = function () { ... } |  |

### <a name="chapter-night-two" id="chapter-night-two"></a>9.2 栈

> [返回目录](#chapter-one)

后进先出，简单来说，一个数组：

```js
var a = [];
a.push(1);
a.push(2);
a.push(3);
console.log(a); // [1, 2, 3]
```

这个步骤叫压栈，就是将数字不停地塞进数组尾部。

```js
a.pop(); // 3
a.pop(); // 2
a.pop(); // 1
console.log(a); []
```

这个步骤叫出栈，就是将数字不停地从数组尾部取出。

栈就类似于叠罗汉，压栈就是先叠第一层，再叠第二层……出栈就是先出最高那层，再出倒数第二层……

### <a name="chapter-night-three" id="chapter-night-three"></a>9.3 调用栈

> [返回目录](#chapter-one)

JavaScript 引擎就是利用栈这种结构管理执行上下文的。

在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。

我们拿一个递归函数来看：

```js
const recursion = (num) => {
  if (num === 1) {
    return 1;
  }
  recursion(num - 1);
};
recursion(3);
```

在这里，先执行 `recursion(3)`，再执行 `recursion(2)`，最后执行 `recursion(1)`，这是压栈步骤。

接着 `recursion(1)` 执行完毕，消除这个；`recursion(2)` 执行完毕，最后 `recursion(3)` 执行完毕。

这种机制就是调用栈。

### <a name="chapter-night-four" id="chapter-night-four"></a>9.4 栈溢出

> [返回目录](#chapter-one)

假如这时候，我们将代码变一变：

```js
const recursion = (num) => {
  if (num === 1) {
    return 1;
  }
  if (num === 2) {
    return 2;
  }
  return recursion(num - 1) + recursion(num - 2);
};
console.log(recursion(100));
```

JavaScript 的调用栈是有大小的，入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，这种错误就是栈溢出。

**jsliang** 运行上面这行代码，放了一会手提就疯狂运转了！

所以有时候看到：超过了最大栈调用大小（Maximum call stack size exceeded），你应该知道是什么问题了。

## <a name="chapter-ten" id="chapter-ten"></a>十 var 的缺陷和 let、const

> [返回目录](#chapter-one)

由于 JavaScript 存在变量提升这种特性，从而导致了很多与直觉不符的代码，这也是 JavaScript 的一个重要设计缺陷。

虽然 ECMAScript6（以下简称 ES6）已经通过引入块级作用域并配合 `let`、`const `关键字，来避开了这种设计缺陷，但是由于 JavaScript 需要保持向下兼容，所以变量提升在相当长一段时间内还会继续存在。

### <a name="chapter-ten-one" id="chapter-ten-one"></a>10.1 作用域

> [返回目录](#chapter-one)

作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

ES5 时候的作用域只有两种：

* **全局作用域**：全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
* **函数作用域**：函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

ES6 有块级作用域的定义：

* **块级作用域**：使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个 `{}` 都可以被看作是一个块级作用域。

```js
// if块
if(1){}

// while 块
while(1){}

// 函数块
function foo(){}
 
// for 循环块
for(let i = 0; i<100; i++){}

// 单独一个块
{}
```

块级作用域其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。

### <a name="chapter-ten-two" id="chapter-ten-two"></a>10.2 题目

> [返回目录](#chapter-one)

```js
function foo(){
  var a = 1;
  let b = 2;
  {
    let b = 3;
    var c = 4;
    let d = 5;
    console.log(a);
    console.log(b);
  }
  console.log(b);
  console.log(c);
  console.log(d);
}   
foo();
```

求打印顺序。

答：1 -> 3 -> 2 -> 4 -> 报错

## <a name="chapter-eleven" id="chapter-eleven"></a>十一 作用域链和闭包

> [返回目录](#chapter-one)

### <a name="chapter-eleven-one" id="chapter-eleven-one"></a>11.1 作用域链和词法作用域

> [返回目录](#chapter-one)

```js
function bar() {
  console.log(myName);
}
function foo() {
  var myName = "jsliang2";
  bar();
}
var myName = "jsliang1";
foo();
```

这段代码输出 `jsliang1`，为什么？

讲解这个问题之前，我们看一下词法作用域：

```js
function foo() {
  var myName = 'jsliang2';
  function bar() {
    console.log(myName);
  }
};
var myName = 'jsliang1';
foo();
```

像这段代码，它的词法作用域链的顺序是：bar 函数作用域 -> foo 函数作用域 -> 全局作用域。

所以在 `bar()` 中查找 `myName`，没找到就查找 `foo()` 的，于是返回 `jsliang2`。

我们回过头来：

```js
function bar() {
  console.log(myName);
}
function foo() {
  var myName = "jsliang2";
  bar();
}
var myName = "jsliang1";
foo();
```

这段代码的词法作用域链是：foo 函数作用域 -> 全局作用域；bar 函数作用域 -> 全局作用域。

所以在 `foo()` 中调用 `bar()`，而 `bar()` 找不到自身的，会去找全局作用域的。

所以什么是 **作用域链** 和 **词法作用域**：

* **作用域链**：从当前函数开始，逐步往全局作用域查找，形成的这一条查找链就是作用域链。
* **词法作用域**：作用域是有代码中函数声明的位置决定的，它是静态的作用域，能够预测代码在执行过程中查找标识符。

**词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。**

### <a name="chapter-eleven-two" id="chapter-eleven-two"></a>11.2 块级作用域

> [返回目录](#chapter-one)

```js
function bar() {
  console.log(myName);
}
function foo() {
  let myName = "jsliang2";
  bar();
}
var myName = "jsliang1";
foo();
```

那么，现在我们将 `jsliang2` 的 `myName` 变量定义为 `let`，会输出什么呢？

答案是：`jsliang1`，这是拦不住的。

### <a name="chapter-eleven-three" id="chapter-eleven-three"></a>11.3 闭包

> [返回目录](#chapter-one)

```js
function foo() {
  let i = 1;
  return function() {
    i++;
    console.log(i);
  }
}
let f = foo();
f(); // 2
f(); // 3
```

在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量。

当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了。

但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。

### <a name="chapter-eleven-four" id="chapter-eleven-four"></a>11.4 如何回收闭包

> [返回目录](#chapter-one)

闭包使用不正确，容易造成内存泄漏：

如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

因此需要注意一个原则：**如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。**

### <a name="chapter-eleven-five" id="chapter-eleven-five"></a>11.5 小结

> [返回目录](#chapter-one)

* 首先，介绍了什么是作用域链，我们把通过作用域查找变量的链条称为作用域链；作用域链是通过词法作用域来确定的，而词法作用域反映了代码的结构。
* 其次，介绍了在块级作用域中是如何通过作用域链来查找变量的。
* 最后，又基于作用域链和词法环境介绍了到底什么是闭包。

## <a name="chapter-twelve" id="chapter-twelve"></a>十二 this

> [返回目录](#chapter-one)

作用域链和 `this` 是两套不同的系统，它们之间基本没太多联系。

`this` 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 `this`。

执行上下文分为 3 种：

* 全局执行上下文
* 函数执行上下文
* `eval` 执行上下文

所以 `this` 对应的也只有这 3 种。

> 注意这里是浏览器中的 `this`，和 Node 中的 `this` 是不一样的。

### <a name="chapter-twelve-one" id="chapter-twelve-one"></a>12.1 全局执行上下文中的 this

> [返回目录](#chapter-one)

在 Chrome 控制台中输入：`this`，你会看到答案：

```js
Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}
```

全局执行上下文中的 `this` 是指向 `Window` 的。

```js
function foo() {
  console.log(this);
}
foo();
```

这段代码也是输出 `Window`，为什么？

记住 `this` 就是谁调用它就指向谁。

我们在全局对象中调用 `foo`，实际上就相当于 `window.foo()` 的一个调用，那么就是指向 `Window`。

> 在执行上面代码之后，其实小伙伴可以在 Chrome 的控制台输入 `window`，会看到里面存在 `foo()` 方法。

### <a name="chapter-twelve-two" id="chapter-twelve-two"></a>12.2 函数执行上下文中的 this

> [返回目录](#chapter-one)

在上面我们知道，一般的调用方法，是调用 `window` 上的方法。

那怎么获取当前函数的 `this` 呢？

#### <a name="chapter-twelve-two-one" id="chapter-twelve-two-one"></a>12.2.1 通过 call/bind/apply 改变 this

> [返回目录](#chapter-one)

```js
this.myName = 'jsliang';
let foo = function() {
  this.myName = 'zhazhaliang';
}
foo();
console.log(window.myName); // 输出啥？
console.log(foo.myName); // 输出啥？
```

这时候的 `this` 指向 `window`，所以输出结果为；

* zhazhaliang
* undefined

通过 `call` 绑定后：

```js
this.myName = 'jsliang';
let foo = function() {
  this.myName = 'zhazhaliang';
}
foo.call(foo);
console.log(window.myName); // 输出啥？
console.log(foo.myName); // 输出啥？
```

输出结果为：

* jsliang
* zhazhaliang

#### <a name="chapter-twelve-two-two" id="chapter-twelve-two-two"></a>12.2.2 通过对象调用方法设置

> [返回目录](#chapter-one)

使用对象来调用其内部的一个方法，该方法的 `this` 是指向对象本身的。

> 案例 1

```js
let myObj = {
  name: 'jsliang',
  showThis: function() {
    console.log(this.name);
  },
};
myObj.showThis(); // 输出啥？
```

输出 `jsliang`。

当然，我们要有自知之明：

> 案例 2

```js
let myObj = {
  myName: 'jsliang',
  showThis: function() {
    console.log(this.myName);
  },
};
let foo = myObj.showThis;
foo(); // 输出啥？
```

这时候它又变成 `window` 指向了，相当于：

> 案例 2 变型

```js
let foo = function() {
  console.log(this.myName);
}
foo();
```

毋庸置疑输出 `undefined`。

> 案例 3

```js
let myObj = {
  name: 'jsliang',
  showThis: function() {
    console.log(this.name);
  },
};
let foo = myObj.showThis;
foo(); // 输出啥？
```

一般来说，这段代码输出应该是 `undefined`。

但是，这里需要注意的是，`window.name` 是当前 `window` 的名称，它是 `window.open()` 打开新网页这个方法的第二个参数的值。

所以这里输出的 `windwo.name` 是个空值 `''`，或者当前存在的 `window` 的名称。

> index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>jsliang</title>
</head>
<body>
  <button class="btn">打开新网页</button>

  <script>
    (function() {
      const btn = document.querySelector('.btn');
      btn.onclick = function() {
        window.open('index.html', 'jsliang 的网页');
      }
    })()
  </script>
</body>
</html>
```

在新打开的网页中的控制台，输入 `window.name`，获取 `jsliang 的网页`。

结论：

* 在全局环境中调用一个函数，函数内部的 `this` 指向的是全局变量 `window`。
* 通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 `this` 指向对象本身。

#### <a name="chapter-twelve-two-three" id="chapter-twelve-two-three"></a>12.2.3 通过构造函数中设置

> [返回目录](#chapter-one)

```js
this.name = 'jsliang';
let Foo = function() {
  this.name = 'zhazhaliang';
}
let foo = new Foo();
console.log(foo.name); // 输出啥？
console.log(window.name); // 输出啥？
```

答案是：

* zhazhaliang
* jsliang

在将这个答案的缘故之前，我们看下 `new Foo()` 中，JavaScript 引擎做了什么事：

* 首先创建一个空对象 `tempObj = {}`。
* 接着调用 `Foo.apply` 方法，将 `tempObj` 作为 `apply` 方法的参数，这样当 `Foo` 的执行上下文创建时，它的 `this` 就指向 `tempObj` 对象。
* 然后执行 `Foo` 函数，此时的 `Foo` 函数执行上下文中的 `this` 指向了 `tempObj` 对象。
* 最后返回 `tempObj` 对象。

```js
function myNew(func, ...args) {
  const tempObj = {};
  func.apply(tempObj, args);
  return tempObj;
}

this.name = 'jsliang';
let Foo = function(name, age) {
  this.name = name;
  this.age = age;
}
let foo = myNew(Foo, 'zhazhaliang', 25);
console.log(foo.name); // 输出啥？
console.log(foo.age); // 输出啥？
console.log(window.name); // 输出啥？
```

如上，我们可以看到此时 `this` 是属于 `tempObj` 的，绑定到 `foo` 上去了，从而获取到：

* zhazhaliang
* 25
* jsliang

当然，了解到这里，我们还是完善下 `new` 这个手写方法：

```js
function myNew(func, ...args) {
  // 1. 判断方法体
  if (typeof func !== 'function') {
    throw '第一个参数必须是方法体';
  }

  // 2. 创建新对象
  const obj = {};

  // 3. 这个对象的 __proto__ 指向 func 这个类的原型对象
  // 即实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性
  obj.__proto__ = Object.create(func.prototype);
  // 为了兼容 IE 可以让步骤 2 和 步骤 3 合并
  // const obj = Object.create(func.prototype);

  // 4. 通过 apply 绑定 this 执行并且获取运行后的结果
  let result = func.apply(obj, args);
  
  // 5. 如果构造函数返回的结果是引用数据类型，则返回运行后的结果
  // 否则返回新创建的 obj
  const isObject = typeof result === 'object' && typeof result !== null;
  const isFunction = typeof result === 'function';
  return isObject || isFunction ? result : obj;
}

// 测试
function Person(name) {
  this.name = name;
  return function() { // 用来测试第 5 点
    console.log('返回引用数据类型');
  };
}
// 用来测试第 2 点和第 3 点
Person.prototype.sayName = function() {
  console.log(`My name is ${this.name}`);
}
const me = myNew(Person, 'jsliang'); // 用来测试第 4 点
me.sayName(); // My name is jsliang
console.log(me); // Person {name: 'jsliang'}

// 用来测试第 1 点
// const you = myNew({ name: 'jsliang' }, 'jsliang'); // 报错：第一个参数必须是方法体
```

### <a name="chapter-twelve-three" id="chapter-twelve-three"></a>12.3 this 设计缺陷和应对方案

> [返回目录](#chapter-one)

* **嵌套函数中的 `this` 不会从外层函数中继承**

```js
var myObj = {
  myName: "jsliang", 
  showThis: function(){
    console.log(this.myName); // 输出啥？
    function bar(){
      console.log(this.myName); // 输出啥？
    }
    bar();
  },
};
myObj.showThis();
```

答案是：

1. jsliang
2. undefined

**解决方法一：通过 `that` 控制 `this` 指向**

```js
var myObj = {
  myName: "jsliang", 
  showThis: function(){
    console.log(this.myName); // 输出啥？
    let that = this;
    function bar(){
      console.log(that.myName); // 输出啥？
    }
    bar();
  },
};
myObj.showThis();
```

这样都输出 `jsliang` 了。

**解决方法二：通过 ES6 的箭头函数解决问题**

```js
var myObj = {
  myName: "jsliang", 
  showThis: function(){
    console.log(this.myName); // 输出啥？
    const bar = () => {
      console.log(this.myName); // 输出啥？
    }
    bar();
  },
};
myObj.showThis();
```

这是因为 ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 `this` 取决于它的外部函数，即谁调用它 `this` 就继承自谁。

* **普通函数中 `this` 指向全局对象 `window`**

在实际工作中，我们并不希望函数执行上下文中的 `this` 默认指向全局对象，因为这样会打破数据的边界，造成一些误操作。

如果要让函数执行上下文中的 `this` 指向某个对象，最好的方式是通过 `call` 方法来显示调用。

这个问题可以通过设置 JavaScript 的 **严格模式** 来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 `this` 值是 `undefined`，这就解决上面的问题了。

### <a name="chapter-twelve-four" id="chapter-twelve-four"></a>12.4 小结

> [返回目录](#chapter-one)

* 当函数作为对象的方法调用时，函数中的 `this` 就是该对象；
* 当函数被正常调用时，在严格模式下，`this` 值是 `undefined`，非严格模式下 `this` 指向的是全局对象 `window`；
* 嵌套函数中的 `this` 不会继承外层函数的 `this` 值。

思考：

```js
let userInfo = {
  name: 'jsliang',
  age: 25,
  sex: 'male',
  updateInfo: function(){
    // 模拟 XMLHttpRequest 请求延时
    setTimeout(function(){
      this.name = "zhazhaliang"
      this.age = 30;
      this.sex = 'female';
    }, 1000);
  },
};

userInfo.updateInfo();
```

解决这里的 `this` 指向问题，求得最终结果：

```js
{
  name: "zhazhaliang",
  age: 30,
  sex: "female",
  updateInfo: function(),
}
```

答案：`setTimeout(() => {})` 即可。

## <a name="chapter-thirteen" id="chapter-thirteen"></a>十三 参考文献

> [返回目录](#chapter-one)

* [ ] [极客时间 - 浏览器工作原理与实践](https://time.geekbang.org/column/intro/100033601)【阅读建议：3.5h+】
* [x] [廖雪峰 - 进程和线程](https://www.liaoxuefeng.com/wiki/1016959663602400/1017627212385376)【阅读建议：10min】

---

> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">jsliang 的文档库</span> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/LiangJunrong/document-library" property="cc:attributionName" rel="cc:attributionURL">梁峻荣</a> 采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。<br />基于<a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/LiangJunrong/document-library" rel="dct:source">https://github.com/LiangJunrong/document-library</a>上的作品创作。<br />本许可协议授权之外的使用权限可以从 <a xmlns:cc="http://creativecommons.org/ns#" href="https://creativecommons.org/licenses/by-nc-sa/2.5/cn/" rel="cc:morePermissions">https://creativecommons.org/licenses/by-nc-sa/2.5/cn/</a> 处获得。