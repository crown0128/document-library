标签划分 - 动态规划
===

> Create by **jsliang** on **2020-07-24 14:33:51**  
> Recently revised in **2020-09-11 15:30:42**

* [动态规划精讲（一） - LeetBook](https://leetcode-cn.com/leetbook/detail/dynamic-programming-1-plus/)
* [动态规划精讲（二） - LeetBook](https://leetcode-cn.com/leetbook/detail/dynamic-programming-2-plus/)
* [动态规划系列 - labuladong的算法小抄](https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie)
* [小浩算法目录汇总（20200422-第五版）](https://mp.weixin.qq.com/s/3eJNKDTZ5y5icMnfv9Is_w)
* [动态一 - 掘金小册](https://juejin.im/book/6844733800300150797/section/6844733800367276039)
* [动态二 - 掘金小册](https://juejin.im/book/6844733800300150797/section/6844733800371453965)

## 掘金小册笔记

动态规划是一种思想。

所谓思想，就是非常好用，好用到爆的套路。

爬楼梯这道题目有两个关键的特征：

1. 要求你给出达成某个目的的解法个数
2. 不要求你给出每一种解法对应的具体路径

### Step1：递归思想分析问题

基于动态规划的思想来做题，我们首先要想到的思维工具就是“倒着分析问题”。“倒着分析问题”分两步走：

1. 定位到问题的终点
2. 站在终点这个视角，思考后退的可能性

所以可以通过公式构造树结构：

* `f(n) = f(n - 1) + f(n - 2)`

这样就可以用递归求解。

```js
/**
* @param {number} n
* @return {number}
*/
const climbStairs = function(n) {
  // 处理递归边界
  if(n === 1) {
    return 1
  }
  if(n === 2){
    return 2
  }
  // 递归计算
  return climbStairs(n-1) + climbStairs(n-2)
};
```

### Step2：记忆化搜索来提效

而斐波那契数列的递归，我们知道它有个问题，就是重复计算。

所以可以通过数组存储相关的记忆：

```js
/**
 * @param {number} n
 * @return {number}
 */
// 定义记忆数组 f
const f = [];
const climbStairs = function (n) {
  if (n == 1) {
    return 1;
  }
  if (n == 2) {
    return 2;
  }
  // 若f[n]不存在，则进行计算
  if (f[n] === undefined) f[n] = climbStairs(n - 1) + climbStairs(n - 2);
  // 若f[n]已经求解过，直接返回
  return f[n];
};
```

### Step3：记忆化搜索转化为动态规划

我们基于树形思维模型来解题时，实际上是站在了一个比较大的未知数量级（也就是最终的那个n），来不断进行拆分，最终拆回较小的已知数量级（f(1)、f(2)）。这个过程是一个明显的自顶向下的过程。

动态规划则恰恰相反，是一个自底向上的过程。它要求我们站在已知的角度，通过定位已知和未知之间的关系，一步一步向前推导，进而求解出未知的值。

由此，我们可以转成动态规划：

```js
/**
 * @param {number} n
 * @return {number}
 */
const climbStairs = function (n) {
  // 初始化状态数组
  const f = [];
  // 初始化已知值
  f[1] = 1;
  f[2] = 2;
  // 动态更新每一层楼梯对应的结果
  for (let i = 3; i <= n; i++) {
    f[i] = f[i - 2] + f[i - 1];
  }
  // 返回目标值
  return f[n];
};
```

### 从题解思路看动态规划

分治问题的核心思想是：把一个问题分解为相互独立的子问题，逐个解决子问题后，再组合子问题的答案，就得到了问题的最终解。

动态规划的思想和“分治”有点相似。不同之处在于，“分治”思想中，各个子问题之间是独立的：比如说归并排序中，子数组之间的排序并不互相影响。而动态规划划分出的子问题，往往是相互依赖、相互影响的。

什么样的题应该用动态规划来做？我们要抓以下两个关键特征：

* **最优子结构**：它指的是问题的最优解包含着子问题的最优解——不管前面的决策如何，此后的状态必须是基于当前状态（由上次决策产生）的最优决策。（这玩意儿叫状态转移方程，大家记一下）。
* **重叠子问题**：它指的是在递归的过程中，出现了反复计算的情况。就这道题来说，图上标红的一系列重复计算的结点印证了这一点。

优先选择这样的分析路径：

1. 递归思想明确树形思维模型：找到问题终点，思考倒退的姿势，往往可以帮助你更快速地明确状态间的关系
2. 结合记忆化搜索，明确状态转移方程
3. 递归代码转化为迭代表达（这一步不一定是必要的，1、2本身为思维路径，而并非代码实现。若你成长为熟手，2中分析出来的状态转移方程可以直接往循环里塞，根本不需要转换）。

### 找硬币问题

```
题目描述：
给定不同面额的硬币 coins 和一个总金额 amount。
编写一个函数来计算可以凑成总金额所需的最少的硬币个数。
如果没有任何一种硬币组合能组成总金额，返回 -1。

示例1：
输入: coins = [1, 2, 5], amount = 11
输出: 3
解释: 11 = 5 + 5 + 1

示例2：
输入: coins = [2], amount = 3
输出: -1
```

> 最值问题是动态规划的常见对口题型，见到最值问题，应该想到动态规划

以 `f(36)` 为例进行推导 **状态转移方程**：

* `f(36) = Math.min(f(36 - c1) + 1, f(36 - c2) + 1, ... f(36 - cn) + 1)`

确定子问题：`f[0] = 0`

所以可以求解：

```js
const coinChange = function (coins, amount) {
  // 用于保存每个目标总额对应的最小硬币个数
  const f = [];
  // 提前定义已知情况
  f[0] = 0;
  // 遍历 [1, amount] 这个区间的硬币总额
  for (let i = 1; i <= amount; i++) {
    // 求的是最小值，因此我们预设为无穷大，确保它一定会被更小的数更新
    f[i] = Infinity;
    // 循环遍历每个可用硬币的面额
    for (let j = 0; j < coins.length; j++) {
      // 若硬币面额小于目标总额，则问题成立
      if (i - coins[j] >= 0) {
        // 状态转移方程
        f[i] = Math.min(f[i], f[i - coins[j]] + 1);
      }
    }
  }
  // 若目标总额对应的解为无穷大，则意味着没有一个符合条件的硬币总数来更新它，本题无解，返回-1
  if (f[amount] === Infinity) {
    return -1;
  }
  // 若有解，直接返回解的内容
  return f[amount];
};
```

> **暂时没清楚**

### 0-1 背包模型

```
有 n 件物品，
物品体积用一个名为 w 的数组存起来，
物品的价值用一个名为 value 的数组存起来；

每件物品的体积用 w[i] 来表示，
每件物品的价值用 value[i] 来表示。

现在有一个容量为 c 的背包，
问你如何选取物品放入背包，
才能使得背包内的物品总价值最大？

每种物品只有 1 件。
```

现在，假设背包已满，容量达到 `c`。

站在 `c` 这个终点往回退，考虑取出一样物品，那么有 `n` 种可能性。

尝试 “取出一件” 表示这个动作对应的变化，那么有可能：

* 这一件物品在背包里
* 这一件物品不在背包里

假设这个物品是 `f(i - 1)`，同时它不在背包里，那么：

* `f(i, c) = f(i - 1, c)`

但是如果物品在背包里，那么取出后价值量和体积量会减少：

* `f(i, c) - value[i] = f(i - 1, c - w[i])`

将减法转换成加法：

* `f(i, c) = f(i - 1, c - w[i]) + value[i]`

基于上面的分析，抽取出自变量和因变量：

* 自变量：物品的索引（`i`）和当前背包内物品的总体积（`v`）
* 因变量：总价值

考虑到存在两个变量，所以通过二维数组来记忆不同状态下的总价值：

* `dp[i][v] = Math.max(dp[i - 1][v], dp[i - 1][v - w[i]] + c[i])`

所以将这个状态转移方程往循环里塞：

```js
for (let i = 1; i <= n; i++) {
  for (let v = w[i]; v <= c; v++) {
    dp[i][v] = Math.max(dp[i - 1][v], dp[i - 1][v - w[i]] + value[i]);
  }
}
```

这时候的时间复杂度是 `O(n)`

那么，现在是二维数组，能不能再进一步优化？

```js
for (let i = 1; i <= n; i++) {
  for (let v = c; v >= w[i]; v--) {
    dp[v] = Math.max(dp[v], d[v - w[i]] + value[i]);
  }
}
```

所以完整代码如下：

```js
// 入参是物品的个数和背包的容量上限，以及物品的重量和价值数组
function knapsack(n, c, w, value) {
  // dp是动态规划的状态保存数组
  const dp = new Array(c + 1).fill(0);
  // res 用来记录所有组合方案中的最大值
  let res = -Infinity;
  for (let i = 1; i <= n; i++) {
    for (let v = c; v >= w[i]; v--) {
      // 写出状态转移方程
      dp[v] = Math.max(dp[v], dp[v - w[i]] + value[i]);
      // 即时更新最大值
      if (dp[v] > res) {
        res = dp[v];
      }
    }
  }
  return res;
}
```

### 最长上升子序列

```
题目描述：
给定一个无序的整数数组，
找到其中最长上升子序列的长度。

示例:
输入: [10,9,2,5,3,7,101,18]
输出: 4
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。

说明:
可能会有多种最长上升子序列的组合，
你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n^2) 。

进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?
```

思路：

对于数组 `[10,9,2,5,3,7,101,18]`，我们先初始化表：

| 索引 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 值 | 10 | 9 | 2 | 5 | 3 | 7 | 101 | 18 |
| 初始 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1

对于每个数组元素来说，如果不存在更长的子序列，那么它默认全为 1。

当我们顺序遍历数组的时候：

* 10 -> 不变
* 9 -> 查看前面有没有比它小的元素（没有） -> 不变
* 2 -> 查看前面有没有比它小的元素（没有） -> 不变
* 5 -> 查看前面有没有比它小的元素（有） -> 查找到有 2，所以 5 对应的值 = f(2) + 1 -> 2
* 3 -> 查看前面有没有比它小的元素（有） -> 查找到有 2，所以 3 对应的值 = f(2) + 1 -> 2
* 7 -> 查看前面有没有比它小的元素（有） -> 查找到有 2、5、3，对应的值为 1、2、2，所以我们取最大的，即 7 对应的值 = f(4) + 1（这样我们需要注意的是，我们取最大值，5 和 3 都是最大，那就取后面的）
* 101……

从而得到题解：

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
// 入参是一个数字序列
const lengthOfLIS = function (nums) {
  // 缓存序列的长度
  const len = nums.length;
  // 处理边界条件
  if (!len) {
    return 0;
  }
  // 初始化数组里面每一个索引位的状态值
  const dp = new Array(len).fill(1);
  // 初始化最大上升子序列的长度为1
  let maxLen = 1;
  // 从第2个元素开始，遍历整个数组
  for (let i = 1; i < len; i++) {
    // 每遍历一个新元素，都要“回头看”，看看能不能延长原有的上升子序列
    for (let j = 0; j < i; j++) {
      // 若遇到了一个比当前元素小的值，则意味着遇到了一个可以延长的上升子序列，故更新当前元素索引位对应的状态
      if (nums[j] < nums[i]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
    // 及时更新上升子序列长度的最大值
    if (dp[i] > maxLen) {
      maxLen = dp[i];
    }
  }
  // 遍历完毕，最后到手的就是最大上升子序列的长度
  return maxLen;
};
```

## 小浩算法 - 动态规划系列

我们把要解决的一个大问题转换成若干个规模较小的同类型问题，当我们求解出这些小问题的答案，大问题便不攻自破。

同时，在求解这些小问题的过程中，我们把需要重复计算的答案记录下来放在数组中，下次如果遇到同样的小问题需要计算，便直接查询出结果。

这就是动态规划。

DP 比固定形式的算法，例如 DFS、二分法、KMP 等，难度在于没有固定的步骤规定第一步第二步做什么，所以 DP 更应该被看作是一种解决问题的思想。

这种思想的本质是：碰到一个规模较大的问题（可以用两三个参数表示），通过若干规模较小的问题的结果来得到（通常会寻求一些特殊的计算逻辑，如求最值等）

通过 5 道题目了解动态规划：

1. 70-爬楼梯
2. 53-最大子序和
3. 300-最长上升子序列
4. 120-三角形最小路径和
5. 64-最小路径和
6. 198-打家劫舍

状态的定义并不一定是最终求解的问题答案，自然也就不能想当然的到最后返回一个 `dp[i]` 就觉得完事，具体问题具体分析，把握住状态的含义才是核心。（谨记）

## 待训练

* [70-爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)
* [746-使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)
* [面试题 08.11-硬币](https://leetcode-cn.com/problems/coin-lcci/)
* [01 背包问题]()
* [300-最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
* [53-最大子序和](https://leetcode-cn.com/problems/maximum-subarray)
* [120-三角形最小路径和](https://leetcode-cn.com/problems/triangle)
* [64-最小路径和](https://leetcode-cn.com/problems/minimum-path-sum)
* [198-打家劫舍](https://leetcode-cn.com/problems/house-robber)
* [213-打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii)
* [337-打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii)
* [343-整数拆分](https://leetcode-cn.com/problems/integer-break)
* [62-不同路径](https://leetcode-cn.com/problems/unique-paths/)
* [63-不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)
* [980-不同路径 III](https://leetcode-cn.com/problems/unique-paths-iii/)

## 简单

* 【中等】061-最小路径和
* 【中等】062-不同路径
* 【中等】063-不同路径II
* 【困难】174-地下城游戏

## 熟练

* 【中等】[486-预测赢家](https://leetcode-cn.com/problems/predict-the-winner/)
* 【中等】239-完全平方数
* 【中等】[377-组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

## 系列：打家劫舍

* 【中等】337-打家劫舍 III