03 - 矩阵的最大非负积
===

> Create by **jsliang** on **2020-09-20 10:32:48**  
> Recently revised in **2020-09-20 11:56:38**

## <a name="chapter-one" id="chapter-one"></a>一 目录

**不折腾的前端，和咸鱼有什么区别**

| 目录 |
| --- |
| [一 目录](#chapter-one) |
| <a name="catalog-chapter-two" id="catalog-chapter-two"></a>[二 题目](#chapter-two) |
| <a name="catalog-chapter-three" id="catalog-chapter-three"></a>[三 解题思路](#chapter-three) |
| <a name="catalog-chapter-four" id="catalog-chapter-four"></a>[四 解题套路](#chapter-four) |

## <a name="chapter-two" id="chapter-two"></a>二 题目

> [返回目录](#chapter-one)

```
给你一个大小为 rows x cols 的矩阵 grid 。

最初，你位于左上角 (0, 0) ，
每一步，你可以在矩阵中 向右 或 向下 移动。

在从左上角 (0, 0) 开始到右下角 (rows - 1, cols - 1) 结束的所有路径中，
找出具有 最大非负积 的路径。

路径的积是沿路径访问的单元格中所有整数的乘积。

返回 最大非负积 对 109 + 7 取余 的结果。如果最大积为负数，则返回 -1 。

注意，取余是在得到最大积之后执行的。

示例 1：

输入：grid = [[-1,-2,-3],
             [-2,-3,-3],
             [-3,-3,-2]]
输出：-1
解释：从 (0, 0) 到 (2, 2) 的路径中无法得到非负积，所以返回 -1

示例 2：

输入：grid = [[1,-2,1],
             [1,-2,1],
             [3,-4,1]]
输出：8
解释：最大非负积对应的路径已经用粗体标出 (1 * 1 * -2 * -4 * 1 = 8)

示例 3：

输入：grid = [[1, 3],
             [0,-4]]
输出：0
解释：最大非负积对应的路径已经用粗体标出 (1 * 0 * -4 = 0)

示例 4：

输入：grid = [[ 1, 4,4,0],
             [-2, 0,0,1],
             [ 1,-1,1,1]]
输出：2
解释：最大非负积对应的路径已经用粗体标出 (1 * -2 * 1 * -1 * 1 * 1 = 2)

提示：

1 <= rows, cols <= 15
-4 <= grid[i][j] <= 4
```

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var maxProductPath = function(grid) {

};
```

根据上面的已知函数，小伙伴们可以先尝试破解本题，确定了自己的答案后再看下面代码。

## <a name="chapter-three" id="chapter-three"></a>三 解题思路

> [返回目录](#chapter-one)

广度优先搜索：

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
const maxProductPath = (grid) => {
  // 1. 设置结果集
  let result = -1;

  // 2. 设置当前层坐标集合
  let nowFloor = [[0, 0]];

  // 3. 设置当前层元素值集合
  let nowFloorValue = [grid[0][0]];

  // 4. 广度优先搜索，一直往下推演
  while (nowFloor.length) {


    // 4.1 设置下一层元素坐标
    const nextFloor = [];

    // 4.2 设置下一层元素坐标值
    const nextFloorValue = [];

    // 4.3 遍历当前层，收集内容
    for (let i = 0; i < nowFloor.length; i++) {

      // 4.3.1 获取坐标
      const [m, n] = nowFloor[i];

      // 4.3.2 获取坐标值
      const value = nowFloorValue[i];

      // 4.3.3 如果还可以往右（注意有负数，判断 undefined）
      if (grid[m][n + 1] !== undefined) {
        nextFloor.push([m, n + 1]);
        nextFloorValue.push(value * grid[m][n + 1]);
      }

      // 4.3.3 如果还可以往下（注意有负数，判断 undefined）
      if (grid[m + 1] && grid[m + 1][n] !== undefined) {
        nextFloor.push([m + 1, n]);
        nextFloorValue.push(value * grid[m + 1][n]);
      }
    }

    // 4.4 收集最大值
    if (nextFloorValue.length === 0) {
      for (let i = 0; i < nowFloorValue.length; i++) {
        if (nowFloorValue[i] > result) {
          result = nowFloorValue[i];
        }
      }
    }

    // 4.5 上下层交接
    nowFloor = nextFloor;
    nowFloorValue = nextFloorValue;
  }

  // 5. 返回结果
  return (result) % (Math.pow(10, 9) + 7);
};

// console.log(maxProductPath(
//   [
//     [-1, -2, -3],
//     [-2, -3, -3],
//     [-3, -3, -2]
//   ]
// )); // -1
// console.log(maxProductPath(
//   [
//     [1, -2, 1],
//     [1, -2, 1],
//     [3, -4, 1]
//   ]
// )); // 8
// console.log(maxProductPath(
//   [
//     [1, 3],
//     [0, -4]
//   ]
// )); // 0
// console.log(maxProductPath(
//   [
//     [1, 4, 4, 0],
//     [-2, 0, 0, 1],
//     [1, -1, 1, 1]
//   ]
// )); // 2
console.log(maxProductPath(
  [
    [1, -1, 2, 1, -1, 0, 0, 4, 3, 2, 0, -2, -2],
    [-2, 3, 3, -1, -1, 0, 0, -2, 4, -3, 3, 0, 0],
    [-4, -1, -1, -2, 2, -1, -2, -2, 0, 3, -1, -4, 1],
    [-3, 4, -3, 0, -3, 1, -3, 1, 4, 4, -4, -4, -2],
    [3, -3, 1, 0, -1, -4, -4, -4, 3, 2, 2, 3, 3],
    [2, -1, -1, -4, -3, -3, 4, 2, 3, 4, 4, -4, 0],
    [4, -1, 2, -3, -1, -1, -3, -4, 4, 4, 4, -3, -1],
    [-3, -4, 4, -2, -1, 2, 3, -1, 2, 3, 4, 4, -4],
    [-3, -1, -2, 1, 1, -1, -3, -4, -3, 1, -3, 3, -4],
    [2, 4, 4, 4, -3, -3, 1, -1, 3, 4, -1, 1, 4],
    [2, -2, 0, 4, -1, 0, -2, 4, -4, 0, 0, 2, -3],
    [1, 1, -3, 0, -4, -4, -4, -4, 0, -1, -4, -1, 0],
    [3, -1, -3, -3, -3, -2, -1, 4, -1, -2, 4, 2, 3]
  ]
)); // 459630706
```

## <a name="chapter-four" id="chapter-four"></a>四 套路分析

> [返回目录](#chapter-one)

本题暂未发现任何套路，如果有但是 **jsliang** 后面发现了的话，会在 GitHub 进行补充。

如果小伙伴有更好的思路想法，或者没看懂其中某种解法，欢迎评论留言或者私聊 **jsliang**~

---

**不折腾的前端，和咸鱼有什么区别！**

![图](https://github.com/LiangJunrong/document-library/blob/master/public-repertory/img/z-index-small.png?raw=true)

**jsliang** 会每天更新一道 LeetCode 题解，从而帮助小伙伴们夯实原生 JS 基础，了解与学习算法与数据结构。

**浪子神剑** 会每天更新面试题，以面试题为驱动来带动大家学习，坚持每天学习与思考，每天进步一点！

扫描上方二维码，关注 **jsliang** 的公众号（左）和 **浪子神剑** 的公众号（右），让我们一起折腾！

> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">jsliang 的文档库</span> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/LiangJunrong/document-library" property="cc:attributionName" rel="cc:attributionURL">梁峻荣</a> 采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。<br />基于<a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/LiangJunrong/document-library" rel="dct:source">https://github.com/LiangJunrong/document-library</a>上的作品创作。<br />本许可协议授权之外的使用权限可以从 <a xmlns:cc="http://creativecommons.org/ns#" href="https://creativecommons.org/licenses/by-nc-sa/2.5/cn/" rel="cc:morePermissions">https://creativecommons.org/licenses/by-nc-sa/2.5/cn/</a> 处获得。