数组组合排序
===

> Create by **jsliang** on **2020-06-19 10:10:14**  
> Recently revised in **2020-06-22 17:57:46**  

## <a name="chapter-one" id="chapter-one"></a>一 目录

**不折腾的前端，和咸鱼有什么区别**

| 目录 |
| --- |
| [一 目录](#chapter-one) |
| <a name="catalog-chapter-two" id="catalog-chapter-two"></a>[二 前言](#chapter-two) |

## <a name="chapter-two" id="chapter-two"></a>二 前言

> [返回目录](#chapter-one)

```js
function doExchange(arr){
  var len = arr.length;
  if(len>=2){
    var len1 = arr[0].length;
    var len2 = arr[1].length;
    var lenBoth = len1 * len2;
    var items = new Array(lenBoth)
    var index = 0;
    for (var i = 0;i<len1;i++){
      for (var j = 0;j<len2;j++){
        items[index] = arr[0][i] + arr[1][j];
        index++
      }
    }
    var newArr = new Array(len - 1)
    for (var i = 2; i < arr.length; i++) {
      newArr[i-1] = arr[i]
    }
    newArr[0] = items;
    return doExchange(newArr)
  }else{
    return arr[0]
  }
}

console.log(doExchange([["1", "2", "3"], ["a", "b", "c"], ["e", "f", "j"]]));
```

```
[ '1ae',
  '1af',
  '1aj',
  '1be',
  '1bf',
  '1bj',
  '1ce',
  '1cf',
  '1cj',
  '2ae',
  '2af',
  '2aj',
  '2be',
  '2bf',
  '2bj',
  '2ce',
  '2cf',
  '2cj',
  '3ae',
  '3af',
  '3aj',
  '3be',
  '3bf',
  '3bj',
  '3ce',
  '3cf',
  '3cj' ]
```

已知存在一个数字类型数组，该数组中的每个数字都不相同，例如：

* `[1, 2, 3]`
* `[2, 3, 5, 6]`

求该数组中各个数字可能具有的组合，例如：

* `[1, 2, 3]`：`[ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ]`
* `[2, 4, 6]`：`[ [2, 4, 6], [2, 6, 4], [4, 2, 6], [4, 6, 2], [6, 2, 4], [6, 4, 2] ]`

欢迎小伙伴们思考，然后评论留言或者私聊 **jsliang**，这里贴下攻略以及详情解释：

> 攻略版

```js
const getArray = (arr) => {
  const result = [];
  
  const arrange = (tempArr) => {
    const tempArrLength = tempArr.length;
    const length = arr.length;
    for (var i = 0; i < length; i++) {
      const index = tempArr.findIndex(item => item === arr[i]);
      if (tempArrLength === length - 1 && index < 0) {
        result.push([...tempArr, arr[i]]);
        continue;
      }
      if (index < 0) {
        arrange([...tempArr, arr[i]]);
      }
    }
  }
  arrange([]);

  return result;
}

console.log(getArray([1, 2, 3]));
// [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ]
```

> 详解版

```js
const getArray = (arr) => {
  // 1. 设置结果集
  const result = [];
  
  // 2. 设置递归函数
  const arrange = (tempArr) => {
    console.log(tempArr); // 注：详情打印结果在下方展示
    const tempArrLength = tempArr.length;
    const length = arr.length;
    // 4. 遍历数组，将数组中的每一项作为开头
    // 假设数组 [1, 2, 3]，那么得出的结果集以这三个数字开头
    for (var i = 0; i < length; i++) {
      // 5. 查看目前遍历的数字是否出现过
      const index = tempArr.findIndex(item => item === arr[i]);
      // 6. 如果没有出现过，且这个临时数组（tempArr）的长度差一个就到了 arr 的长度
      // 那么我们将其推给 result 数组，表明这是一个求解集，中断本次循环
      if (tempArrLength === length - 1 && index < 0) {
        result.push([...tempArr, arr[i]]);
        continue;
      }
      // 7. 否则我们调用递归函数，将这种组合进一步拓展
      if (index < 0) {
        arrange([...tempArr, arr[i]]);
      }
    }
  }
  // 3. 调用递归函数，传递空数组，表明目前啥都没有
  arrange([]);

  // 8. 返回结果
  return result;
}

console.log(getArray([1, 2, 3]));
// [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ]
// ------
// tempArr 履历
// []
// [ 1 ]
// [ 1, 2 ]
// [ 1, 3 ]
// [ 2 ]
// [ 2, 1 ]
// [ 2, 3 ]
// [ 3 ]
// [ 3, 1 ]
// [ 3, 2 ]
// [ [ 1, 2, 3 ],
//   [ 1, 3, 2 ],
//   [ 2, 1, 3 ],
//   [ 2, 3, 1 ],
//   [ 3, 1, 2 ],
//   [ 3, 2, 1 ] ]
```

## <a name="chapter-three" id="chapter-three"></a>三 多维数组排列组合

> [返回目录](#chapter-one)

题目：

现在有一批手机，它有各种信息：

* 颜色：`['白色', '黑色', '金色']`
* 内存大小：`['16G', '32G', '64G']`
* 版本：`['联通', '移动', '电信']`

要求：编写一个算法，实现 颜色 + 内存大小 + 版本的组合，类似于：

* `['白色', '16G', '联通']`
* `['白色', '32G', '联通']`
* `['黑色', '16G', '电信']`
* ……

请输出所有的组合。

```js
const combine = (arr) => {
  
};

// 后端给出的数据
const colorList = ['白色', '黑色', '金色'];
const sizeList = ['16G', '32G', '64G'];
const versionList = ['联通', '移动', '电信'];

console.log(combine([colorList, sizeList, versionList]));
```

---

题解：

**首先**，我们需要知道的是，我们并不确定数组给出的长度，只知道里面是个二维数组，可能有颜色、内存大小、版本、优惠套餐等内容。

**然后**，我们据此可以先将基本代码列出来：

```js
const combine = (arr) => {
  // 1. 设置结果集
  const result = [];

  // 2. 遍历收集
  // do something
  
  // 3. 返回结果
  return result;
};

const colorList = ['白色', '黑色', '金色'];
const sizeList = ['16G', '32G', '64G'];
const versionList = ['联通', '移动', '电信'];

console.log(
  combine([
    colorList,
    sizeList,
    versionList,
  ])
);
```

思路最简单的是暴力无疑，如果我们知道 `arr` 中具体有多少长度，那么我们可以按照正常的思路编写：

```js
const combine = (arr) => {
  // 1. 设置结果集
  const result = [];

  // 2. 遍历收集
  for (let i = 0; i < arr[0].length; i++) {
    for (let j = 0; j < arr[1].length; j++) {
      for (let k = 0; k < arr[2].length; k++) {
        result.push([arr[0][i], arr[1][j], arr[2][k]]);
      }
    }
  }
  
  // 3. 返回结果
  return result;
};

const colorList = ['白色', '黑色', '金色'];
const sizeList = ['16G', '32G', '64G'];
const versionList = ['联通', '移动', '电信'];

console.log(
  combine([
    colorList,
    sizeList,
    versionList,
  ])
);
```

这样，我们就通过简单的方法获取到了组合：

```js
[
  [ '白色', '16G', '联通' ], [ '白色', '16G', '移动' ], [ '白色', '16G', '电信' ],
  [ '白色', '32G', '联通' ], [ '白色', '32G', '移动' ], [ '白色', '32G', '电信' ],
  [ '白色', '64G', '联通' ], [ '白色', '64G', '移动' ], [ '白色', '64G', '电信' ],
  [ '黑色', '16G', '联通' ], [ '黑色', '16G', '移动' ], [ '黑色', '16G', '电信' ],
  [ '黑色', '32G', '联通' ], [ '黑色', '32G', '移动' ], [ '黑色', '32G', '电信' ],
  [ '黑色', '64G', '联通' ], [ '黑色', '64G', '移动' ], [ '黑色', '64G', '电信' ],
  [ '金色', '16G', '联通' ], [ '金色', '16G', '移动' ], [ '金色', '16G', '电信' ],
  [ '金色', '32G', '联通' ], [ '金色', '32G', '移动' ], [ '金色', '32G', '电信' ],
  [ '金色', '64G', '联通' ], [ '金色', '64G', '移动' ], [ '金色', '64G', '电信' ],
]
```

但是，如果我们不确定传入的字段有多少呢？就好比：

```js
const combine = (arr) => {

};

const colorList = ['白色', '黑色', '金色'];
const sizeList = ['16G', '32G', '64G'];
const versionList = ['联通', '移动', '电信'];
const setMealList = ['套餐一', '套餐二', '套餐三'];

console.log(
  combine([
    colorList,
    sizeList,
    versionList,
    setMealList,
  ])
);
```

这时候我们就需要 4 次 `for()` 循环进行嵌套处理？

如果是 5 个，那就 5 次 `for()` 循环嵌套处理？

这无疑是令人细思极恐的，那么，有没有法子简化下操作呢？

有的，递归：

```js
const combine = (arr) => {
  // 1. 设置结果集
  const result = [];

  // 2. 设置递归函数
  const ergodic = () => {

  };

  // 3. 调用递归函数
  for (let i = 0; i < combine[0].length; i++) {
    ergodic(combine[0][i]);
  }
  
  // 4. 返回结果
  return result;
};

const colorList = ['白色', '黑色', '金色'];
const sizeList = ['16G', '32G', '64G'];
const versionList = ['联通', '移动', '电信'];
const setMealList = ['套餐一', '套餐二', '套餐三'];

console.log(
  combine([
    colorList,
    sizeList,
    versionList,
    setMealList,
  ])
);
```

如上，`ergodic()` 的内容我们先不管，我们首先需要做的是缕清思路：

1. 

```js
const combine = (arr) => {
  // 1. 如果是 [] 或者 [colorList] 这种单个的，则直接返回
  if (arr.length < 2) {
    return arr[0];
  } else { // 2. 两两组合得到最终结果
    let tempResult = [];
    for (let i = 0; i < arr[0].length; i++) {
      for (let j = 0; j < arr[1].length; j++) {
        // 2.1 如果是单个 * 单个，则返回两者组合
        if (typeof arr[0][i] === 'string') {
          tempResult.push([arr[0][i], arr[1][j]]);
        } else {
          // 2.2 如果前面已经组合过了，通过 ... 解构数组
          tempResult.push([...arr[0][i], arr[1][j]]);
        }
      }
    }
    // 2.3 重组数组
    arr = [tempResult, ...arr.slice(2)];
    // 2.4 返回最终结果
    return combine(arr);
  }
};

const colorList = ['白色', '黑色', '金色'];
const sizeList = ['16G', '32G', '64G'];
const versionList = ['联通', '移动', '电信'];
const setMealList = ['套餐一', '套餐二', '套餐三'];

console.log(
  combine([
    colorList,
    sizeList,
    versionList,
    setMealList,
  ])
); 
```

## <a name="chapter-three" id="chapter-three"></a>三 参考文献

> [返回目录](#chapter-one)

* [【博客园】凌云之翼《多个数组的组合排序算法》](https://www.cnblogs.com/liugang-vip/p/5985210.html)
* [【CSDN】向然《js求N个数组所有组合》](https://blog.csdn.net/baidu_32519511/article/details/82980032)
* [【简书】少苏菇凉《js数组排列组合(收录一种简单的方法)》](https://www.jianshu.com/p/b6e31d6139cc)
* [【微信公众号】程序员黑叔《又懒得加班了，带你去电商公司写商品中心》](https://mp.weixin.qq.com/s/vovEX2YoivRAf9ErgfI2qw)

---

> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">jsliang 的文档库</span> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/LiangJunrong/document-library" property="cc:attributionName" rel="cc:attributionURL">梁峻荣</a> 采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。<br />基于<a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/LiangJunrong/document-library" rel="dct:source">https://github.com/LiangJunrong/document-library</a>上的作品创作。<br />本许可协议授权之外的使用权限可以从 <a xmlns:cc="http://creativecommons.org/ns#" href="https://creativecommons.org/licenses/by-nc-sa/2.5/cn/" rel="cc:morePermissions">https://creativecommons.org/licenses/by-nc-sa/2.5/cn/</a> 处获得。