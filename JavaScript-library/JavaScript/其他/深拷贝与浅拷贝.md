深拷贝与浅拷贝
===

> create by **jsliang** on **2019-09-29 17:17:27**  
> Recently revised in **2019-10-14 16:57:44**

## <a name="chapter-one" id="chapter-one">一 目录</a>

**不折腾的前端，和咸鱼有什么区别**

| 目录 |
| --- | 
| [一 目录](#chapter-one) | 
| <a name="catalog-chapter-two" id="catalog-chapter-two"></a>[二 前言](#chapter-two) |
| <a name="catalog-chapter-three" id="catalog-chapter-three"></a>[三 解题](#chapter-three) |
| <a name="catalog-chapter-four" id="catalog-chapter-four"></a>[四 执行测试](#chapter-four) |
| <a name="catalog-chapter-five" id="catalog-chapter-five"></a>[五 LeetCode Submit](#chapter-five) |
| <a name="catalog-chapter-six" id="catalog-chapter-six"></a>[六 知识点](#chapter-six) |
| <a name="catalog-chapter-seven" id="catalog-chapter-seven"></a>[七 解题思路](#chapter-seven) |

## <a name="chapter-two" id="chapter-two">二 前言</a>

> [返回目录](#chapter-one)

* 面试官 VS LV1 小白

面试官：讲讲基本类型与引用类型，引址和引值的区别。

* 面试官 VS LV2 渣渣

面试官：讲讲浅拷贝和深拷贝的区别，然后讲讲一些方式吧。

* 面试官 VS LV3 熟练工

面试官：手写个深拷贝，讲讲这个深拷贝可能会出现什么问题。

* 浅拷贝、深拷贝以及基础数据类型
* 浅拷贝方式
* 深拷贝方式
  * 深拷贝注意爆栈

在讨论 **浅拷贝和深拷贝** 之前，

在 **jsliang** 的日常工作中，时常受到大佬的提醒：注意不要在 React 开发的时候，直接修改数据。

protected

public

private

## <a name="chapter-three" id="chapter-three">三 基本类型与引用类型</a>

> [返回目录](#chapter-one)

数据分为基本数据类型和对象数据类型。

* 基本数据类型：String、Number、Boolean、Null、Undefined、Symbol。直接存储在栈中的数据。
* 对象数据类型：Array、Object。存储的是该对象在栈中引用，真实的数据存储在内存中。

## <a name="chapter-four" id="chapter-four">四 浅拷贝和神拷贝</a>

> [返回目录](#chapter-one)

```js
// 基本数据类型
let str1 = '123';
str2 = str1;
str2 = '456';
console.log(str1); // '123'
console.log(str2); // '456'

// 对象数据类型
let arr1 = [1, 2, 3];
arr2 = arr1;
arr2.push(4);
console.log(arr1); // [1, 2, 3, 4]
console.log(arr2); // [1, 2, 3, 4]
```

如上，对基本数据类型进行拷贝，然后修改新数据后，不会影响到原数据；而对对象数据类型进行拷贝，然后修改新数据后，会影响到原数据。

通过实验我们先定性一个结论：

* 浅拷贝：浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。
* 深拷贝：深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

## <a name="chapter-five" id="chapter-five">五 浅拷贝</a>

> [返回目录](#chapter-one)

在探讨通过工具进行浅拷贝之前，我们尝试 “手写” 一份：

```js
let arr1 = [1, 2, ['jsliang', 'JavaScriptLiang'], 4];

arr2 = arr1;
arr2[2].push('LiangJunrong');
arr2[3] = 5;
console.log(arr1); // [1, 2, ['jsliang', 'JavaScriptLiang', 'LiangJunrong'], 5];
console.log(arr2); // [1, 2, ['jsliang', 'JavaScriptLiang', 'LiangJunrong'], 5];
```

可以看出，如果我们只是通过 `=` 进行赋值操作，那么我们修改新数据后，会对原数据产生影响。

那么，我们尝试使用浅拷贝：

```js

const arr1 = [1, 2, ['jsliang', 'JavaScriptLiang'], 4];

const shallowCopy = (arr) => {
  const dst = [];
  for (let prop in arr) {
    if (arr.hasOwnProperty(prop)) {
        dst[prop] = arr[prop];
    }
  }
  return dst;
}

const arr2 = shallowCopy(arr1);
arr2[2].push('LiangJunrong');
arr2[3] = 5;

console.log(arr1); // [ 1, 2, [ 'jsliang', 'JavaScriptLiang', 'LiangJunrong' ], 4 ]
console.log(arr2); // [ 1, 2, [ 'jsliang', 'JavaScriptLiang', 'LiangJunrong' ], 5 ]
```

可以看到，这里我们修改对象数据类型里面的对象数据类型的时候，还是会影响到原数据，但是如果我们修改里面的基本数据类型的时候，就不会影响到原数据了。

那么，在更深入讲解探讨之前，我们先聊聊为了更好讲解上面代码思路，我做了啥：

1. 查找 `for...in`，发现属于 [**JavaScript 语句和声明**](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements)，所以给自己文档库起了个目录 [**语句和声明**](https://github.com/LiangJunrong/document-library/tree/master/JavaScript-library/JavaScript/%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A3%B0%E6%98%8E)。
2. 发现 `for...in` 和 `for...of` 相似，于是分别查了 [**for...in**](https://github.com/LiangJunrong/document-library/blob/master/JavaScript-library/JavaScript/%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A3%B0%E6%98%8E/%E8%BF%AD%E4%BB%A3%E5%99%A8/for...in.md) 和 [**for...of**](https://github.com/LiangJunrong/document-library/blob/master/JavaScript-library/JavaScript/%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A3%B0%E6%98%8E/%E8%BF%AD%E4%BB%A3%E5%99%A8/for...of.md)，顺带对着两个进行了对比 [**for...in 和 for...of 对比**](https://github.com/LiangJunrong/document-library/blob/master/JavaScript-library/JavaScript/%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A3%B0%E6%98%8E/%E8%BF%AD%E4%BB%A3%E5%99%A8/for...in%26for...of.md)。
3. 发现 `for...of` 还可以涉及到继承和原型链，于是顺带将之前面试写的文章弄过来：[**继承和原型链**](https://github.com/LiangJunrong/document-library/blob/master/JavaScript-library/JavaScript/%E5%85%B6%E4%BB%96/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE.md)。
4. 查找 `hasOwnProperty`，发现我还没建 `Object` 分类，于是新建了目录：[**Object**](https://github.com/LiangJunrong/document-library/tree/master/JavaScript-library/JavaScript/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/Object)，并写好了 [**hasOwnProperty**](https://github.com/LiangJunrong/document-library/blob/master/JavaScript-library/JavaScript/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/Object/hasOwnProperty.md)。

闲扯完毕，我们还是讲解下上面代码为啥能浅拷贝数据：

* `for...in`：遍历 `Object` 对象 `arr1`，将可枚举值列举出来。
* `hasOwnProperty()`：检查该枚举值是否属于该对象 `arr1`，如果是继承过来的就去掉，如果是自身的则进行拷贝。

这样，我们就成功实现了浅拷贝，并且了解了其中涉及的知识点~

## <a name="chapter-six" id="chapter-six">六 深拷贝</a>

> [返回目录](#chapter-one)

## <a name="chapter-seven" id="chapter-seven">七 前言</a>

> [返回目录](#chapter-one)

---

> **jsliang** 广告推送：  
> 也许小伙伴想了解下云服务器  
> 或者小伙伴想买一台云服务器  
> 或者小伙伴需要续费云服务器  
> 欢迎点击 **[云服务器推广](https://github.com/LiangJunrong/document-library/blob/master/other-library/Monologue/%E7%A8%B3%E9%A3%9F%E8%89%B0%E9%9A%BE.md)** 查看！

[![图](../../../public-repertory/img/z-small-seek-ali-3.jpg)](https://promotion.aliyun.com/ntms/act/qwbk.html?userCode=w7hismrh)
[![图](../../../public-repertory/img/z-small-seek-tencent-2.jpg)](https://cloud.tencent.com/redirect.php?redirect=1014&cps_key=49f647c99fce1a9f0b4e1eeb1be484c9&from=console)

> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">jsliang 的文档库</span> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/LiangJunrong/document-library" property="cc:attributionName" rel="cc:attributionURL">梁峻荣</a> 采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。<br />基于<a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/LiangJunrong/document-library" rel="dct:source">https://github.com/LiangJunrong/document-library</a>上的作品创作。<br />本许可协议授权之外的使用权限可以从 <a xmlns:cc="http://creativecommons.org/ns#" href="https://creativecommons.org/licenses/by-nc-sa/2.5/cn/" rel="cc:morePermissions">https://creativecommons.org/licenses/by-nc-sa/2.5/cn/</a> 处获得。