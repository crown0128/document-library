浅拷贝与深拷贝
===

> create by **jsliang** on **2019-09-29 17:17:27**  
> Recently revised in **2019-10-15 23:42:03**

开篇点题：

* **本文将递归探索关于《浅拷贝和深拷贝》中牵扯的知识点，希望小伙伴们以深拷贝的形式记录到脑海中。**

```js
const deepCloneKnowledgePoints = {
  title: '浅拷贝和深拷贝',
  chapterOne: {
    title: "章节一",
    point: [
      "浅拷贝和深拷贝初探索",
      "基本数据类型和引用数据类型",
    ],
  },
  chapterTwo: {
    title: "章节二",
    point: [
      "手写浅拷贝",
      "Object.assign()",
      "Array.prototype.concat()",
      "Array.prototype.slice()",
    ],
    extend: [
      "for...in",
      "for...of",
      "for...in 和 for...of 的区别",
      "hasOwnProperty",
    ],
  },
  chapterThree: {
    title: "章节三",
    point: [
      "手写深拷贝",
      "JSON.parse(JSON.stringify())",
      "函数库 Lodash",
      "框架 jQuery",
    ],
    extend: [
      "typeof",
      "instanceof",
      "constructor",
      {
        point: "Object.prototype.toString.call()",
        extend: [
          "Function.prototype.apply()",
          "Function.prototype.bind()",
          "Function.prototype.call()",
        ],
      },
    ],
  },
};
```

## <a name="chapter-one" id="chapter-one">一 目录</a>

**不折腾的前端，和咸鱼有什么区别**

| 目录 |
| --- | 
| [一 目录](#chapter-one) | 
| <a name="catalog-chapter-two" id="catalog-chapter-two"></a>[二 前言](#chapter-two) |
| <a name="catalog-chapter-three" id="catalog-chapter-three"></a>[三 基本类型与引用类型](#chapter-three) |
| <a name="catalog-chapter-four" id="catalog-chapter-four"></a>[四 浅拷贝和深拷贝](#chapter-four) |
| <a name="catalog-chapter-five" id="catalog-chapter-five"></a>[五 浅拷贝](#chapter-five) |
| &emsp;[5.1 手写浅拷贝](#chapter-five-one) |
| &emsp;[5.2 Object.assign()](#chapter-five-two) |
| &emsp;[5.3 Array.prototype.concat()](#chapter-five-three) |
| &emsp;[5.4 Array.prototype.slice()](#chapter-five-four) |
| <a name="catalog-chapter-six" id="catalog-chapter-six"></a>[六 深拷贝](#chapter-six) |
| &emsp;[6.1 手写深拷贝](#chapter-six-one) |
| &emsp;[6.2 JSON.parse(JSON.stringify())](#chapter-six-two) |
| &emsp;[6.3 函数库 Lodash](#chapter-six-three) |
| &emsp;[6.4 框架 jQuery](#chapter-six-four) |
| <a name="catalog-chapter-seven" id="catalog-chapter-seven"></a>[七 总结](#chapter-seven) |

## <a name="chapter-two" id="chapter-two">二 前言</a>

> [返回目录](#chapter-one)

* 面试官 VS LV1 小白

面试官：讲讲基本类型与引用类型，引址和引值的区别。

* 面试官 VS LV2 渣渣

面试官：讲讲浅拷贝和深拷贝的区别，然后讲讲一些方式吧。

* 面试官 VS LV3 熟练工

面试官：手写个深拷贝，讲讲这个深拷贝可能会出现什么问题。

* 浅拷贝、深拷贝以及基础数据类型
* 浅拷贝方式
* 深拷贝方式
  * 深拷贝注意爆栈

在讨论 **浅拷贝和深拷贝** 之前，

在 **jsliang** 的日常工作中，时常受到大佬的提醒：注意不要在 React 开发的时候，直接修改数据。

protected

public

private

开篇点题，给出最终比较：

| | 和原数据是否指向同一对象 | 原数据为基本数据类型 | 原数据包含子对象 | 
| --- | --- | --- | --- |
| 赋值 | 是 | 改变【会】使原数据一同改变 | 改变【会】使原数据一同改变 |
| 浅拷贝 | 否 | 改变【不会】使原数据一同改变 | 改变【会】使原数据一同改变 |
| 深拷贝 | 否 | 改变【不会】使原数据一同改变 | 改变【不会】使原数据一同改变 |

## <a name="chapter-three" id="chapter-three">三 基本类型与引用类型</a>

> [返回目录](#chapter-one)

数据分为基本数据类型和对象数据类型。

* 基本数据类型：String、Number、Boolean、Null、Undefined、Symbol。直接存储在栈中的数据。
* 对象数据类型：Array、Object。存储的是该对象在栈中引用，真实的数据存储在内存中。

## <a name="chapter-four" id="chapter-four">四 浅拷贝和深拷贝</a>

> [返回目录](#chapter-one)

```js
// 基本数据类型
let str1 = '123';
str2 = str1;
str2 = '456';
console.log(str1); // '123'
console.log(str2); // '456'

// 对象数据类型
let arr1 = [1, 2, 3];
arr2 = arr1;
arr2.push(4);
console.log(arr1); // [1, 2, 3, 4]
console.log(arr2); // [1, 2, 3, 4]
```

如上，对基本数据类型进行拷贝，然后修改新数据后，不会影响到原数据；而对对象数据类型进行拷贝，然后修改新数据后，会影响到原数据。

通过实验我们先定性一个结论：

* 浅拷贝：浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。
* 深拷贝：深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

## <a name="chapter-five" id="chapter-five">五 浅拷贝</a>

> [返回目录](#chapter-one)

### <a name="chapter-five-one" id="chapter-five-one">5.1 手写浅拷贝</a>

> [返回目录](#chapter-one)

在探讨通过工具进行浅拷贝之前，我们尝试 “手写” 一份浅拷贝：

```js
let arr1 = [1, 2, ['jsliang', 'JavaScriptLiang'], 4];

arr2 = arr1;
arr2[2].push('LiangJunrong');
arr2[3] = 5;
console.log(arr1); // [1, 2, ['jsliang', 'JavaScriptLiang', 'LiangJunrong'], 5];
console.log(arr2); // [1, 2, ['jsliang', 'JavaScriptLiang', 'LiangJunrong'], 5];
```

可以看出，如果我们只是通过 `=` 进行赋值操作，那么我们修改新数据后，会对原数据产生影响。

那么，我们尝试使用浅拷贝：

```js

const arr1 = [1, 2, ['jsliang', 'JavaScriptLiang'], 4];

const shallowCopy = (arr) => {
  const dst = [];
  for (let prop in arr) {
    if (arr.hasOwnProperty(prop)) {
        dst[prop] = arr[prop];
    }
  }
  return dst;
}

const arr2 = shallowCopy(arr1);
arr2[2].push('LiangJunrong');
arr2[3] = 5;

console.log(arr1); // [ 1, 2, [ 'jsliang', 'JavaScriptLiang', 'LiangJunrong' ], 4 ]
console.log(arr2); // [ 1, 2, [ 'jsliang', 'JavaScriptLiang', 'LiangJunrong' ], 5 ]
```

可以看到，这里我们修改对象数据类型里面的对象数据类型的时候，还是会影响到原数据，但是如果我们修改里面的基本数据类型的时候，就不会影响到原数据了。

那么，在更深入讲解探讨之前，我们先聊聊为了更好讲解上面代码思路，我做了啥：

1. 查找 `for...in`，发现属于 [**JavaScript 语句和声明**](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements)，所以给自己文档库起了个目录 [**语句和声明**](https://github.com/LiangJunrong/document-library/tree/master/JavaScript-library/JavaScript/%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A3%B0%E6%98%8E)。
2. 发现 `for...in` 和 `for...of` 相似，于是分别查了 [**for...in**](https://github.com/LiangJunrong/document-library/blob/master/JavaScript-library/JavaScript/%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A3%B0%E6%98%8E/%E8%BF%AD%E4%BB%A3%E5%99%A8/for...in.md) 和 [**for...of**](https://github.com/LiangJunrong/document-library/blob/master/JavaScript-library/JavaScript/%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A3%B0%E6%98%8E/%E8%BF%AD%E4%BB%A3%E5%99%A8/for...of.md)，顺带对着两个进行了对比 [**for...in 和 for...of 对比**](https://github.com/LiangJunrong/document-library/blob/master/JavaScript-library/JavaScript/%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A3%B0%E6%98%8E/%E8%BF%AD%E4%BB%A3%E5%99%A8/for...in%26for...of.md)。
3. 发现 `for...of` 还可以涉及到继承和原型链，于是顺带将之前面试写的文章弄过来：[**继承和原型链**](https://github.com/LiangJunrong/document-library/blob/master/JavaScript-library/JavaScript/%E5%85%B6%E4%BB%96/%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE.md)。
4. 查找 `hasOwnProperty`，发现我还没建 `Object` 分类，于是新建了目录：[**Object**](https://github.com/LiangJunrong/document-library/tree/master/JavaScript-library/JavaScript/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/Object)，并写好了 [**hasOwnProperty**](https://github.com/LiangJunrong/document-library/blob/master/JavaScript-library/JavaScript/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/Object/hasOwnProperty.md)。

闲扯完毕，我们还是讲解下上面代码为啥能浅拷贝数据：

* `for...in`：遍历 `Object` 对象 `arr1`，将可枚举值列举出来。
* `hasOwnProperty()`：检查该枚举值是否属于该对象 `arr1`，如果是继承过来的就去掉，如果是自身的则进行拷贝。

这样，我们就成功实现了浅拷贝，并且了解了其中涉及的知识点~

下面我们再介绍 3 种便捷形式，实现快速浅拷贝。

### <a name="chapter-five-two" id="chapter-five-two">5.2 Object.assign()</a>

> [返回目录](#chapter-one)

`Object.assign()` 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。

但是需要注意的是，`Object.assgin()` 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。

```js
const obj1 = {
  username: 'LiangJunrong',
  skill: {
    play: ['basketball', 'computer game'],
    read: 'book',
  },
  girlfriend: ['1 号备胎', '2 号备胎', '3 号备胎'],
};
const obj2 = Object.assign({}, obj1);
obj2.username = 'jsliang'; // 修改基本类型
obj2.skill.read = 'computer book'; // 修改二层基本类型
obj2.skill.play = ['footboll']; // 修改二层引用类型
obj2.girlfriend = ['之前的都是瞎吹的！'];
console.log(obj1);
// { username: 'LiangJunrong',
//   skill: { play: [ 'footboll' ], read: 'computer book' },
//   girlfriend: [ '1 号备胎', '2 号备胎', '3 号备胎' ] }
console.log(obj2);
// { username: 'jsliang',
//   skill: { play: [ 'footboll' ], read: 'computer book' },
//   girlfriend: [ '之前的都是瞎吹的！' ] }
```

可以看到的是，`Object.assign()` 对于第一层的数据来说，是深拷贝，对于第二层及以上的数据来说，是浅拷贝。

### <a name="chapter-five-three" id="chapter-five-three">5.3 Array.prototype.concat()</a>

> [返回目录](#chapter-one)

`concat()` 是数组的一个内置方法，用户合并两个或者多个数组。

这个方法不会改变现有数组，而是返回一个新数组。

详细内容可以看 **jsliang** 的文章或者看 **MDN** 的文章：

* [jsliang - Array.prototype.concat()](https://github.com/LiangJunrong/document-library/blob/master/JavaScript-library/JavaScript/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/Array/concat.md)
* [MDN - Array.prototype.concat()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)

在这里，我们通过 `concat()` 来浅拷贝一个数组：

```js
const arr1 = [
  1,
  {
    username: 'jsliang',
  },
];

let arr2 = arr1.concat();
arr2[0] = 2;
arr2[1].username = 'LiangJunrong';
console.log(arr1);
// [ 1, { username: 'LiangJunrong' } ]
console.log(arr2);
// [ 2, { username: 'LiangJunrong' } ]
```

看到这里，小伙伴们应该明白，通过 `concat()` 进行的浅拷贝，可以修改里面的基本数据类型而不影响原值，但是修改里面的对象数据类型，就会影响到原有值了。

### <a name="chapter-five-four" id="chapter-five-four">5.4 Array.prototype.slice()</a>

> [返回目录](#chapter-one)

`slice()` 也是数组的一个内置方法，该方法会返回一个新的对象。

`slice()` 不会改变原数组。

详细可以看下 **jsliang** 的 `concat` 或者直接看 **MDN** 的文献：

* [jsliang - Array.prototype.concat()](https://github.com/LiangJunrong/document-library/blob/master/JavaScript-library/JavaScript/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/Array/concat.md)
* [MDN - Array.prototype.concat()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)

```js
const arr1 = [
  1,
  {
    username: 'jsliang',
  },
];

let arr2 = arr1.slice();
arr2[0] = 2;
arr2[1].username = 'LiangJunrong';
console.log(arr1);
// [ 1, { username: 'LiangJunrong' } ]
console.log(arr2);
// [ 2, { username: 'LiangJunrong' } ]
```

可以看到的是，它和前面的 `concat()` 表现的浅拷贝一模一样，如果小伙伴希望研究更深层次的内容，可以看下 `Array.prototype.concat()` 和 `Array.prototype.slice()` 的源码具体实现。

## <a name="chapter-six" id="chapter-six">六 深拷贝</a>

> [返回目录](#chapter-one)

### <a name="chapter-six-one" id="chapter-six-one">6.1 手写深拷贝</a>

> [返回目录](#chapter-one)

那么，手写的深拷贝，要怎么实现呢？

我们采用递归方法实现深度克隆：

1. 遍历对象、数组直到里面都是基本数据类型。
2. 复制数据到新数组中

```js
// 定义检测数据类型的功能函数
const checkedType = (target) => {
  return Object.prototype.toString.call(target).slice(8, -1);
}

// 实现深度克隆对象或者数组
const clone = (target) => {
  // 判断拷贝的数据类型
  // 初始化变量 result 成为最终数据
  let result, targetType = checkedType(target);
  if (targetType === 'Object') {
    result = {};
  } else if (targetType === 'Array') {
    result = [];
  } else {
    return target;
  }

  // 遍历目标数据
  for (let i in target) {
    // 获取遍历数据结构的每一项值
    let value = target[i];
    // 判断目标结构里的每一项值是否存在对象或者数组
    if (checkedType(value) === 'Object' || checkedType(value) === 'Array') {
      // 如果对象或者数组中还嵌套了对象或者数组，那么继续遍历
      result[i] = clone(value);
    } else {
      result[i] = value;
    }
  }

  // 返回最终值
  return result;
}

const obj1 = [
  1,
  'Hello!',
  { name: 'jsliang1' },
  [
    {
      name: 'LiangJunrong1',
    }
  ],
]
const obj2 = clone(obj1);
obj2[0] = 2;
obj2[1] = 'Hi!';
obj2[2].name = 'jsliang2';
obj2[3][0].name = 'LiangJunrong2';

console.log(obj1);
// [
//   1,
//   'Hello!',
//   { name: 'jsliang1' },
//   [
//     { name: 'LiangJunrong1' },
//   ],
// ]

console.log(obj2);
// [
//   2,
//   'Hi!',
//   { name: 'jsliang2' },
//   [
//     { name: 'LiangJunrong2' },
//   ],
// ]
```

下面讲解下这份深拷贝代码：

**首先**，我们先看检查类型的那行代码：`Object.prototype.toString.call(target).slice(8, -1)`。

在说这行代码之前，我们先讲下检测 JavaScript 数据类型的 4 种方式：

* **方式一：typeof**：

判断 `typeof null`，会得到 `object`；

判断构造函数 `typeof new String('String')` 或者 `typeof new Number(123)` 也会得到 `object`。

即通过 `typeof` 进行数据类型判断会有一定的问题。

详细研究可以看 **jsliang** 的学习文档[《typeof》](https://github.com/LiangJunrong/document-library/blob/master/JavaScript-library/JavaScript/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-typeof.md)


* **方式二：instanceof**：

`instanceof` 主要用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

它也可以用来判断数据类型，但是如果你去了解它，你会发现它有点诡异，毕竟 `'string' instanceof String` 返回的是 `false`，而 `new String() instanceof String` 返回的才是 `true`。

详细研究可以看 **jsliang** 的学习文档[《instanceof》](https://github.com/LiangJunrong/document-library/blob/master/JavaScript-library/JavaScript/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-instanceof.md)

* **方式三：constructor**：

`constructor` 和前面的 `typeof` 以及 `instanceof` 不同，它两属于 **表达式和运算符** 分类下的，而 `constructor` 是直接关系到内置对象 `Object` 下。

当然，这里我们讲的是校验数据类型，通过 `[].constructor === Array` 或者 `(1).constructor === Number` 会返回 `true`。

但是很遗憾的表示，当你使用 `null.constructor` 或者 `undefined.constructor` 它会毫不留情的给你报：`Uncaught TypeError: Cannot read property 'constructor' of null at <anonymous>:1:5`

详细研究可以看 **jsliang** 的学习文档[《Object.prototype.constructor》](https://github.com/LiangJunrong/document-library/blob/master/JavaScript-library/JavaScript/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/Object/constructor.md)

* **方式四：Object.prototype.toString.call()**：

在前面三种心有余而力不足的情况下，`Object.prototype.toString.call()` 就显得稳定实用了。

如果你看过 jQuery 源码，你会发现它的数据类型检测也是通过这个实现的（`jQuery.type(obj)`）。

在检测数据类型方面，你不管检测 `Object.prototype.toString.call('aaa')`、`Object.prototype.toString.call(null)` 亦或者 `Object.prototype.toString.call(undefined)` 都能得到你要的类型格式：`[object String]`、`[object Null]`、`[object Undefined]`。

详细研究可以看 **jsliang** 的学习文档[《Object.prototype.toString》](https://github.com/LiangJunrong/document-library/blob/master/JavaScript-library/JavaScript/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/Object/toString.md)

如上，我们解决了手写深拷贝的事儿，如果说哪里会用到的话，估计就是面试的时候，面试官可能要你手写一个吧~

至于工作的时候，咱们会采用一些便捷的方法。

### <a name="chapter-six-two" id="chapter-six-two">6.2 JSON.parse(JSON.stringify())</a>

> [返回目录](#chapter-one)

> 缺少文档：`JSON.parse()`、`JSON.stringify()`、`JSON.parse(JSON.stringify()) 的核心机制`

如果说怎样的深拷贝是最便捷的，那无疑就是 `JSON.parse(JSON.stringify())` 了。

* `JSON.stringify()`：将对象转成 JSON 字符串。
* `JSON.parse()`：将字符串解析成对象。

通过 `JSON.parse(JSON.stringify())` 将 JavaScript 对象转序列化（转换成 JSON 字符串），再将其还原成 JavaScript 对象，一去一来我们就产生了一个新的对象，而且对象会开辟新的栈，从而实现深拷贝。

> 注意，该方法的局限性：  
> 1、不能存放函数或者 Undefined，否则会丢失函数或者 Undefined；  
> 2、不要存放时间对象，否则会变成字符串形式；  
> 3、不能存放 RegExp、Error 对象，否则会变成空对象；  
> 4、不能存放 NaN、Infinity、-Infinity，否则会变成 null；  
> 5、……更多请自行填坑，具体来说就是 JavaScript 和 JSON 存在差异，两者不兼容的就会出问题。

```js
const arr1 = [
  1,
  {
    username: 'jsliang',
  },
];

let arr2 = JSON.parse(JSON.stringify(arr1));
arr2[0] = 2;
arr2[1].username = 'LiangJunrong';
console.log(arr1);
// [ 1, { username: 'jsliang' } ]
console.log(arr2);
// [ 2, { username: 'LiangJunrong' } ]
```

### <a name="chapter-six-three" id="chapter-six-three">6.3 函数库 Lodash</a>

> [返回目录](#chapter-one)

Lodash 作为一个深受大家喜爱的、优秀的 JavaScript 函数库/工具库，它里面有非常好用的封装好的功能，大家可以去试试：

* [Lodash](http://lodash.net/)

这里我们查看下它的 `cloneDeep()` 方法：

* [Lodash - _.cloneDeep(value)](https://lodash.net/docs/4.16.1.html#_clonedeepvalue)

可以看到，该方法会递归拷贝 `value`。

在这里，我们体验下它的 `cloneDeep()`：

```js
//  npm i -S lodash
var _ = require('lodash');

const obj1 = [
  1,
  'Hello!',
  { name: 'jsliang1' },
  [
    {
      name: 'LiangJunrong1',
    }
  ],
]
const obj2 = _.cloneDeep(obj1);
obj2[0] = 2;
obj2[1] = 'Hi!';
obj2[2].name = 'jsliang2';
obj2[3][0].name = 'LiangJunrong2';

console.log(obj1);
// [
//   1,
//   'Hello!',
//   { name: 'jsliang1' },
//   [
//     { name: 'LiangJunrong1' },
//   ],
// ]

console.log(obj2);
// [
//   2,
//   'Hi!',
//   { name: 'jsliang2' }, 
//   [
//     { name: 'LiangJunrong2' },
//   ],
// ]
```

这里我们使用的是 Node 安装其依赖包的形式，如果需要用 MDN 等，小伙伴可以前往它官网瞅瞅。（地址在本节开头）

### <a name="chapter-six-four" id="chapter-six-four">6.4 框架 jQuery</a>

> [返回目录](#chapter-one)

当然，不可厚非你的公司还在用着 jQuery，可能还需要兼容 IE6/7/8，或者你使用 React，但是有些场景还使用了 jQuery，毕竟 jQuery 是个强大的框架。

下面我们尝试下使用 jQuery 的 `extend()` 进行深拷贝：

> index.html

```js
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <p>尝试 jQuery 深拷贝</p>
  <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.js"></script>
  <script>
    $(function() {
      const obj1 = [
        1,
        'Hello!',
        { name: 'jsliang1' },
        [
          {
            name: 'LiangJunrong1',
          }
        ],
      ]
      const obj2 = {};
      /**
       * @name jQuery深拷贝
       * @description $.extend(deep, target, object1, object2...)
       * @param {Boolean} deep 可选 true 或者 false，默认是 false，所以一般如果需要填写，最好是 true。
       * @param {Object} target 需要存放的位置
       * @param {Object} object 可以有 n 个原数据
       */
      $.extend(true, obj2, obj1);
      obj2[0] = 2;
      obj2[1] = 'Hi!';
      obj2[2].name = 'jsliang2';
      obj2[3][0].name = 'LiangJunrong2';

      console.log(obj1);
      // [
      //   1,
      //   'Hello!',
      //   { name: 'jsliang1' },
      //   [
      //     { name: 'LiangJunrong1'},
      //   ],
      // ];

      console.log(obj2);
      // [
      //   2,
      //   'Hi!',
      //   { name: 'jsliang2' },
      //   [
      //     { name: 'LiangJunrong2' },
      //   ],
      // ];
    });
  </script>
</body>
</html>
```

这里由于 Node 直接引用包好像没尝试成功，所以咱通过 `index.html` 的形式，引用了 jQuery 的 CDN 包，从而尝试了它的深拷贝。

> 推荐通过 `live-server` 来实时监控 HTML 文件的变化

## <a name="chapter-seven" id="chapter-seven">七 总结</a>

> [返回目录](#chapter-one)

* **参考文献**：

1. [Lodash clone 系列](https://lodash.net/docs/4.16.1.html#_clonevalue)
2. [浅拷贝与深拷贝](https://juejin.im/post/5b5dcf8351882519790c9a2e)
3. [深拷贝的终极探索](https://yanhaijing.com/javascript/2018/10/10/clone-deep/)
4. [深拷贝与浅拷贝的实现（一）](http://www.alloyteam.com/2017/08/12978/)
5. [深入浅出深拷贝与浅拷贝](https://juejin.im/post/5c6ffac85188252e46626b92)
6. [什么是 js 深拷贝和浅拷贝及其实现方式](https://www.haorooms.com/post/js_copy_sq)
7. [JavaScript 浅拷贝和深拷贝](https://www.kancloud.cn/ljw789478944/interview/397319)
8. [js 深拷贝 vs 浅拷贝](https://juejin.im/post/59ac1c4ef265da248e75892b)
9. [深拷贝的终极探索（99%的人都不知道）](https://segmentfault.com/a/1190000016672263)

---

> **jsliang** 广告推送：  
> 也许小伙伴想了解下云服务器  
> 或者小伙伴想买一台云服务器  
> 或者小伙伴需要续费云服务器  
> 欢迎点击 **[云服务器推广](https://github.com/LiangJunrong/document-library/blob/master/other-library/Monologue/%E7%A8%B3%E9%A3%9F%E8%89%B0%E9%9A%BE.md)** 查看！

[![图](../../../public-repertory/img/z-small-seek-ali-3.jpg)](https://promotion.aliyun.com/ntms/act/qwbk.html?userCode=w7hismrh)
[![图](../../../public-repertory/img/z-small-seek-tencent-2.jpg)](https://cloud.tencent.com/redirect.php?redirect=1014&cps_key=49f647c99fce1a9f0b4e1eeb1be484c9&from=console)

> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">jsliang 的文档库</span> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/LiangJunrong/document-library" property="cc:attributionName" rel="cc:attributionURL">梁峻荣</a> 采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。<br />基于<a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/LiangJunrong/document-library" rel="dct:source">https://github.com/LiangJunrong/document-library</a>上的作品创作。<br />本许可协议授权之外的使用权限可以从 <a xmlns:cc="http://creativecommons.org/ns#" href="https://creativecommons.org/licenses/by-nc-sa/2.5/cn/" rel="cc:morePermissions">https://creativecommons.org/licenses/by-nc-sa/2.5/cn/</a> 处获得。