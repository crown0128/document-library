浏览器工作原理和实践
===

> Create by **jsliang** on **2020-10-05 15:48:25**  
> Recently revised in **2020-10-07 21:42:22**

<!-- 目录开始 -->
## <a name="chapter-one" id="chapter-one"></a>一 目录

**不折腾的前端，和咸鱼有什么区别**

| 目录 |
| --- |
| [一 目录](#chapter-one) |
| <a name="catalog-chapter-two" id="catalog-chapter-two"></a>[二 前言](#chapter-two) |
| <a name="catalog-chapter-three" id="catalog-chapter-three"></a>[三 一个页面 4 个进程](#chapter-three) |
| &emsp;[3.1 进程和线程](#chapter-three-one) |
| &emsp;[3.2 单进程浏览器](#chapter-three-two) |
| &emsp;[3.3 多进程浏览器](#chapter-three-three) |
| &emsp;[3.4 评论区问题](#chapter-three-four) |
| <a name="catalog-chapter-four" id="catalog-chapter-four"></a>[四 TCP 协议：保证页面文件完整送达浏览器](#chapter-four) |
| &emsp;[4.1 评论区问题](#chapter-four-one) |
| <a name="catalog-chapter-five" id="catalog-chapter-five"></a>[五 HTTP 请求：站点二次打开速度很快](#chapter-five) |
| &emsp;[5.1 HTTP 请求过程](#chapter-five-one) |
| &emsp;[5.2 为什么站点第二次打开速度很快](#chapter-five-two) |
| &emsp;[5.3 登录态如何保持](#chapter-five-three) |
| <a name="catalog-chapter-six" id="catalog-chapter-six"></a>[六 从输入 URL 到页面呈现的过程](#chapter-six) |
| <a name="catalog-chapter-seven" id="catalog-chapter-seven"></a>[七 浏览器渲染过程](#chapter-seven) |
| &emsp;[7.1 DOM 树的构建过程](#chapter-seven-one) |
| &emsp;[7.2 CSS 规则树的构建过程](#chapter-seven-two) |
| &emsp;[7.3 布局](#chapter-seven-three) |
| &emsp;[7.4 小结](#chapter-seven-four) |
| &emsp;[7.5 评论区问题](#chapter-seven-five) |
| <a name="catalog-chapter-eight" id="catalog-chapter-eight"></a>[八 变量提升](#chapter-eight) |
| <a name="catalog-chapter-night" id="catalog-chapter-night"></a>[九 JavaScript 栈溢出](#chapter-night) |
| &emsp;[9.1 函数调用](#chapter-night-one) |
| &emsp;[9.2 栈](#chapter-night-two) |
| &emsp;[9.3 调用栈](#chapter-night-three) |
| &emsp;[9.4 栈溢出](#chapter-night-four) |
| <a name="catalog-chapter-ten" id="catalog-chapter-ten"></a>[十 var 的缺陷和 let、const](#chapter-ten) |
| &emsp;[10.1 作用域](#chapter-ten-one) |
| &emsp;[10.2 题目](#chapter-ten-two) |
| <a name="catalog-chapter-eleven" id="catalog-chapter-eleven"></a>[十一 作用域链和闭包](#chapter-eleven) |
| &emsp;[11.1 作用域链和词法作用域](#chapter-eleven-one) |
| &emsp;[11.2 块级作用域](#chapter-eleven-two) |
| &emsp;[11.3 闭包](#chapter-eleven-three) |
| &emsp;[11.4 如何回收闭包](#chapter-eleven-four) |
| &emsp;[11.5 小结](#chapter-eleven-five) |
| <a name="catalog-chapter-twelve" id="catalog-chapter-twelve"></a>[十二 this](#chapter-twelve) |
| &emsp;[12.1 全局执行上下文中的 this](#chapter-twelve-one) |
| &emsp;[12.2 函数执行上下文中的 this](#chapter-twelve-two) |
| &emsp;&emsp;[12.2.1 通过 call/bind/apply 改变 this](#chapter-twelve-two-one) |
| &emsp;&emsp;[12.2.2 通过对象调用方法设置](#chapter-twelve-two-two) |
| &emsp;&emsp;[12.2.3 通过构造函数中设置](#chapter-twelve-two-three) |
| &emsp;[12.3 this 设计缺陷和应对方案](#chapter-twelve-three) |
| &emsp;[12.4 小结](#chapter-twelve-four) |
| <a name="catalog-chapter-thirteen" id="catalog-chapter-thirteen"></a>[十三 JavaScript 内存机制](#chapter-thirteen) |
| &emsp;[13.1 JavaScript 数据类型](#chapter-thirteen-one) |
| &emsp;[13.2 为什么要区分堆和栈](#chapter-thirteen-two) |
| &emsp;[13.3 闭包在内存中](#chapter-thirteen-three) |
| <a name="catalog-chapter-fourteen" id="catalog-chapter-fourteen"></a>[十四 垃圾回收](#chapter-fourteen) |
| &emsp;[14.1 栈垃圾回收](#chapter-fourteen-one) |
| &emsp;[14.2 堆垃圾回收](#chapter-fourteen-two) |
| &emsp;[14.3 新生代和老生代](#chapter-fourteen-three) |
| &emsp;&emsp;[14.3.1 新生代 - 副垃圾回收器](#chapter-fourteen-three-one) |
| &emsp;&emsp;[14.3.2 老生代 - 主垃圾回收器](#chapter-fourteen-three-two) |
| &emsp;[14.4 全停顿](#chapter-fourteen-four) |
| <a name="catalog-chapter-fifteen" id="catalog-chapter-fifteen"></a>[十五 V8 如何执行一段 JavaScript 代码](#chapter-fifteen) |
| &emsp;[15.1 编译器和解释器](#chapter-fifteen-one) |
| &emsp;[15.2 V8 如何执行一段 JavaScript 代码](#chapter-fifteen-two) |
| <a name="catalog-chapter-sixteen" id="catalog-chapter-sixteen"></a>[十六 消息队列和事件循环](#chapter-sixteen) |
| <a name="catalog-chapter-seventeen" id="catalog-chapter-seventeen"></a>[十七 setTimeout](#chapter-seventeen) |
| &emsp;[17.1 浏览器实现 setTimeout](#chapter-seventeen-one) |
| &emsp;[17.2 使用 setTimeout 注意事项](#chapter-seventeen-two) |
| &emsp;[17.3 小结](#chapter-seventeen-three) |
| <a name="catalog-chapter-eighteen" id="catalog-chapter-eighteen"></a>[十八 XMLHttpRequest](#chapter-eighteen) |
| &emsp;[18.1 回调函数](#chapter-eighteen-one) |
| &emsp;[18.2 XMLHttpRequest 运作机制](#chapter-eighteen-two) |
| &emsp;[18.3 XMLHttpRequest 使用过程中的 “坑”](#chapter-eighteen-three) |
| <a name="catalog-chapter-nighteen" id="catalog-chapter-nighteen"></a>[十九 宏任务和微任务](#chapter-nighteen) |
| &emsp;[19.1 宏任务](#chapter-nighteen-one) |
| &emsp;[19.2 微任务](#chapter-nighteen-two) |
| &emsp;[19.3 监听 DOM 变化方法演变](#chapter-nighteen-three) |
| <a name="catalog-chapter-twenty" id="catalog-chapter-twenty"></a>[二十 Promise](#chapter-twenty) |
| <a name="catalog-chapter-twenty-one" id="catalog-chapter-twenty-one"></a>[二十一 async/await](#chapter-twenty-one) |
| &emsp;[21.1 21.1 生成器 VS 协程](#chapter-twenty-one-one) |
| <a name="catalog-chapter-twenty-two" id="catalog-chapter-twenty-two"></a>[二十二 DOM](#chapter-twenty-two) |
| &emsp;[22.1 什么是 DOM](#chapter-twenty-two-one) |
| &emsp;[22.2 如何生成 DOM](#chapter-twenty-two-two) |
| &emsp;[22.3 JavaScript 如何影响 DOM](#chapter-twenty-two-three) |
| <a name="catalog-chapter-twenty-three" id="catalog-chapter-twenty-three"></a>[二十三 CSS 阻塞问题](#chapter-twenty-three) |
| <a name="catalog-chapter-twenty-four" id="catalog-chapter-twenty-four"></a>[二十四 其他](#chapter-twenty-four) |
| <a name="catalog-chapter-twenty-five" id="catalog-chapter-twenty-five"></a>[二十五 参考文献](#chapter-twenty-five) |
<!-- 目录结束 -->

## <a name="chapter-two" id="chapter-two"></a>二 前言

> [返回目录](#chapter-one)

浏览器 3 个大的进化路线：

* 第一个是应用程序 Web 化。
* 第二个是 Web 应用移动化。
* 第三个是 Web 操作系统化。

为什么要学习浏览器工作原理：

* 准确评估 Web 开发项目的可行性。桌面端、客户端还是其他方式。
* 从更高维度审视页面。输入 URL 到页面呈现，哪些角度优化，如何高效加载。
* 在快节奏的技术迭代中把握本质。Node.js 的推进，前端逐步稳定。

本书内容：

* 开篇词（1 讲）
* 宏观视角下的浏览器（6 讲）
* 浏览器中的 JavaScript 执行机制（5 讲）
* V8 工作原理（3 讲）
* 浏览器中的页面循环系统（6 讲）
* 浏览器中的页面（8 讲）
* 浏览器中的网络（3 讲）
* 浏览器安全（5 讲）
* 结束语（3 讲）
* 额外加餐（6 讲）

## <a name="chapter-three" id="chapter-three"></a>三 一个页面 4 个进程

> [返回目录](#chapter-one)

Chrome 也有任务管理器的，再标签栏右键可以看到有任务管理器的菜单。点击之后会发现 Chrome 启动了 4 个进程。

### <a name="chapter-three-one" id="chapter-three-one"></a>3.1 进程和线程

> [返回目录](#chapter-one)

已知代码：

```js
A = 1+2
B = 20/5
C = 7*8
```

按 **单线程** 来处理，那就分 4 步走，第一步处理 A，第二步处理 B……第 4 步显示最后计算的结果。

按 **多线程** 来处理，第一步用 3 个线程同时处理前 3 个任务，第二步来执行显示结果。

而 **线程是不能单独存在的，它是由进程来启动和管理的**。

所谓 **进程**，就是启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放 **代码**、运行中的 **数据** 和一个执行任务的 **主线程**。

对于操作系统来说，**一个任务就是一个进程**。打开一个浏览器就是启动一个浏览器进程，打开一个记事本就是启动一个记事本进程，打开两个记事本就是启动了 2 个记事本进。

我们把 **进程中的子任务称为线程**。就好比浏览器中有浏览器主进程、GPU 进程、网络进程、渲染进程等。渲染进程就负责将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页。

进程和线程之间的关系：

1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。如果 `B = 20 / 0`，那么导致这一线程报错，从而整个进程崩溃。
2. 线程之间共享进程中的数据。在多线程处理中，第二步骤可以调取第一步骤存放到数据中的内容。
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。就好比浏览器开着，内存占用越来越多，从而导致操作卡顿。但是当浏览器关闭之后，这些内存都会被系统回收调。
4. 进程之间的内容相互隔离。如果 A 页面崩溃了，B 页面不会受此影响；A 页面的数据也不会串入 B 页面中。

### <a name="chapter-three-two" id="chapter-three-two"></a>3.2 单进程浏览器

> [返回目录](#chapter-one)

早在 2007 年之前，市面上的浏览器都是单进程的。

单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。

这样就会有诸多问题：

1. **不稳定**。某个音频、视频插件出了问题，整个页面就崩溃了，整个浏览器崩溃了；JavaScript 过于复杂，渲染引擎模块崩了，整个浏览器崩溃了。
2. **不流畅**。同一时刻只能有一个模块执行，在 JavaScript 写了个死循环，结果整个浏览器就失去响应，变卡顿。
3. **不安全**。如果你安装了某个插件，然后页面运行这个插件就意味着插件操作你的代码。

### <a name="chapter-three-three" id="chapter-three-three"></a>3.3 多进程浏览器

> [返回目录](#chapter-one)

1. 解决不稳定问题。一个页面崩溃不会导致整个浏览器崩溃。
2. 解决不流畅问题。JavaScript 死循环也就影响当前页面。
3. 解决不安全问题。渲染进程不能读取硬盘的数据和获取操作系统权限。

最新的 Chrome 浏览器包括：

* 1 个浏览器主进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
* 1 个 GPU 进程：实现 3D CSS 的效果，网页、Chrome 的 UI 页面绘制。
* 1 个网络进程：主要负责页面的网络资源加载。
* 多个渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页
* 多个插件进程

其中渲染进程负责 解析、渲染、JavaScript 执行、合成网页图片。

渲染进程运行在沙箱里面，不能读写硬盘上的数据，不能获取操作系统权限。

这时候就可以呼应本章开头，一个页面 4 个进程即打开 1 个页面，至少有 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及一个渲染进程。如果有插件运行，还需要假设插件进程。

缺陷：

* 更高的资源占用。存储多了，消耗更多的内存资源。
* 更复杂的体系架构。各个模块之间的耦合性、扩展性等。

### <a name="chapter-three-four" id="chapter-three-four"></a>3.4 评论区问题

> [返回目录](#chapter-one)

* 问：偶尔还会碰到一些由于单个页面卡死最终崩溃导致所有页面崩溃的情况，请问这是什么原因？
* 答：

通常情况下是一个页面使用一个进程，但是，有一种情况，叫 “同一站点(same-site)”。

具体地讲，我们将 “同一站点” 定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口。

这块和同源策略稍微有点不同。

```
https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080
```

这 3 个都是同一站点，因为协议都是 `https`，根域名都是 `geekband.org`。

Chrome 有个策略，就是当你从 A 标签中打开新页面 B，而新页面 B 和 A 页面属于同一个站点，那么新页面 B 就复用页面 A 的渲染过程。

这种情况下， B 页面崩溃了，会导致 A 页面同时崩溃，因为使用了同一个渲染过程。

## <a name="chapter-four" id="chapter-four"></a>四 TCP 协议：保证页面文件完整送达浏览器

> [返回目录](#chapter-one)

在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中又有很大概率丢失或者出错。那么如何保证页面文件能被完整地送达浏览器呢？

1. 互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。
2. IP 负责把数据包送达目的主机。
3. UDP 负责把数据包送达具体应用。
4. TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。

### <a name="chapter-four-one" id="chapter-four-one"></a>4.1 评论区问题

> [返回目录](#chapter-one)

* **如何理解 HTTP 和 TCP 的关系？**

HTTP 协议和 TCP 协议都是 TCP/IP 协议簇的子集。

HTTP 协议属于应用层，TCP 协议属于传输层，HTTP 协议位于 TCP 协议的上层。

请求方要发送的数据包，在应用层加上 HTTP 头以后会交给传输层的 TCP协议处理，应答方接收到的数据包，在传输层拆掉 TCP头 以后交给应用层的 HTTP 协议处理。

建立 TCP 连接后会顺序收发数据，请求方和应答方都必须依据 HTTP 规范构建和解析 HTTP 报文。

* **浏览器同时打开多个相同标签，数据怎么传达具体页签？**

网络进程知道每个 TCP 链接所对应的标签，所以接收数据后，会把数据分发给对应的渲染进程。

## <a name="chapter-five" id="chapter-five"></a>五 HTTP 请求：站点二次打开速度很快

> [返回目录](#chapter-one)

HTTP 协议，是建立在 TCP 连接基础之上的。

HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。

HTTP 是浏览器使用最广的协议。

### <a name="chapter-five-one" id="chapter-five-one"></a>5.1 HTTP 请求过程

> [返回目录](#chapter-one)

对于网站：`http://time.geekbang.org/index.html`

1. 构建请求。`GET / index.html HTTP1.1`
2. 查找缓存。判断浏览器是否进行强缓存或者协商缓存。[浏览器 - 浏览器缓存](https://github.com/LiangJunrong/document-library/blob/master/other-library/interview/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98.md)
3. 准备 IP 地址和端口。浏览器请求第一步是和服务器建立 TCP 连接，而建立 TCP 连接需要准备 IP 地址和端口号，那就好通过 DNS 解析获取端口号了。[计算机网络 - DNS](https://github.com/LiangJunrong/document-library/blob/master/other-library/interview/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS.md)
4. 等待 TCP 队列。同一个域名最多只能建立 6 个 TCP 连接。所以如果有 10 个请求，那么有 4 个会进入等待状态；如果少于 6 个进入下一步。
5. 建立 TCP 连接。[计算机网络 - TCP](https://github.com/LiangJunrong/document-library/blob/master/other-library/interview/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP.md)。
6. 发送 HTTP 请求。HTTP 请求报文由 3 部分组成：**请求行**、**请求报头** 和 **请求正文**。
7. 服务端处理 HTTP 请求。HTTP 响应报文由 3 部分组成：**状态码**、**响应报头** 和 **响应报文**。
8. 断开 TCP 连接。如果浏览器或者服务器的头信息加入了 `Connection: Keep-Alive`，那 TCP 连接会保持打开状态，浏览器可以通过同一个 TCP 连接持续发送请求。否则则会中断。

### <a name="chapter-five-two" id="chapter-five-two"></a>5.2 为什么站点第二次打开速度很快

> [返回目录](#chapter-one)

浏览器缓存：

* DNS 缓存
* 页面资源缓存

### <a name="chapter-five-three" id="chapter-five-three"></a>5.3 登录态如何保持

> [返回目录](#chapter-one)

登录态：用户的登录状态，用来标识这个用户的身份。

* `Cookie` 登录态实现

如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。

当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。

服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。

* 其他实现方案

1. 存储型。根据 `token` 去服务端存储上查找用户信息，查找不到就校验失败，反之成功。
2. 计算型。将用户信息（`userId`）加密成字符串，这个字符串就是 `token`，服务端解析用户传递过来的 `userId + generateTimestamp` 来判断是否过期。
3. 全自动登录。用户登录过一次后，保存登录态，避免每次执行用例都调用登录接口，无需手动登录。

## <a name="chapter-six" id="chapter-six"></a>六 从输入 URL 到页面呈现的过程

> [返回目录](#chapter-one)

省略。

## <a name="chapter-seven" id="chapter-seven"></a>七 浏览器渲染过程

> [返回目录](#chapter-one)

### <a name="chapter-seven-one" id="chapter-seven-one"></a>7.1 DOM 树的构建过程

> [返回目录](#chapter-one)

为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。

在 Chrome 控制台 Console 模块，输入 `document` 就可以看到完整的 DOM 树结构。

可以通过 JavaScript 来修改 DOM：

```js
document.getElementsByTagName("p")[0].innerText = "black"
```

这行代码会把第一个 `<p>` 标签的内容修改为 `black`。

### <a name="chapter-seven-two" id="chapter-seven-two"></a>7.2 CSS 规则树的构建过程

> [返回目录](#chapter-one)

**首先**，CSS 样式来源主要有三种：通过 link 引用的外部 CSS 文件

* 通过 `link` 引用的外部 CSS 文件
* `<style>` 标记内的 CSS
* 元素的 `style` 属性内嵌的 CSS

和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。

在 Chrome 控制台 Console 模块，输入 `document.styleSheets` 就可以看到完整的 CSS 规则树。

**然后**，一些属性值需要进行标准化操作：

```css
body { font-size: 2em; }
p { color: blue; }
```

这个就会变成：

```css
body { font-size: 32px; }
p { color: rgb(0, 0, 255) }
```

这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

**最后**，计算 DOM 树中每个节点的具体位置

这涉及到 CSS 的继承规则和层叠规则。

* CSS 继承：每个 DOM 节点都包含有父节点的样式。在 Chrome 的 Elements 模块可以看到某个标签不仅仅有当前标签，还继承 `body`、`html` 等的属性。
* CSS 层叠：合并来自多个源的属性值。

### <a name="chapter-seven-three" id="chapter-seven-three"></a>7.3 布局

> [返回目录](#chapter-one)

接下来需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。

1. 创建布局树
2. 布局计算

### <a name="chapter-seven-four" id="chapter-seven-four"></a>7.4 小结

> [返回目录](#chapter-one)

一个完整的渲染流程大致可总结为如下：

* 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
* 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
* 创建布局树，并计算元素的布局信息。
* 对布局树进行分层，并生成分层树。
* 为每个图层生成绘制列表，并将其提交到合成线程。
* 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
* 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
* 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

### <a name="chapter-seven-five" id="chapter-seven-five"></a>7.5 评论区问题

> [返回目录](#chapter-one)

* **下载 CSS 文件阻塞，会阻塞 DOM 树的合成吗？**

当从服务器接收 HTML 页面的第一批数据时，DOM 解析器就开始工作了，在解析过程中，如果遇到了JS脚本，如下所示：

```html
<html>
  <body>
    jsliang
    <script>
      document.write("--foo")
    </script>
  </body>
</html>
```

那么 DOM 解析器会先执行 JavaScript 脚本，执行完成之后，再继续往下解析。

那么第二种情况复杂点了，我们内联的脚本替换成js外部文件，如下所示：

```html
<html>
  <body>
    jsliang
    <script type="text/javascript" src="foo.js"></script>
  </body>
</html>
```

这种情况下，当解析到 JavaScript 的时候，会先暂停 DOM 解析，并下载 `foo.js` 文件，下载完成之后执行该段 JS 文件，然后再继续往下解析 DOM。这就是 JavaScript 文件为什么会阻塞 DOM 渲染。

我们再看第三种情况，还是看下面代码：

```html
<html>
  <head>
    <style type="text/css" src = "theme.css" />
  </head>
  <body>
    <p>jsliang</p>
    <script>
      let e = document.getElementsByTagName('p')[0]
      e.style.color = 'blue'
    </script>
  </body>
</html>
```

当我在 JavaScript 中访问了某个元素的样式，那么这时候就需要等待这个样式被下载完成才能继续往下执行，所以在这种情况下，CSS 也会阻塞 DOM 的解析。

所以 JS 和 CSS 都有可能会阻塞 DOM 解析。

## <a name="chapter-eight" id="chapter-eight"></a>八 变量提升

> [返回目录](#chapter-one)

只有理解了 JavaScrip 的执行上下文，你才能更好地理解 JavaScript 语言本身，比如变量提升、作用域和闭包等。

```js
showName();
console.log(myname);
var myname = 'jsliang';
function showName() {
  console.log('函数 showName 被执行');
}
```

按道理来说，我们的 `console` 先于 `var myname` 定义，打印 `console` 应该会报错。

但是实际上打印的是 `undefined`。

同样，`showName()` 函数是后面定义的，按道理也会报错，实际上会打印  `函数 showName 被执行`。

这个就是变量提升。

从浏览器工作原理上看，这段代码会变成：

```diff
+ // 函数声明前置
+ function showName() {
+  console.log('函数 showName 被执行');
+ }
+ var myname; // 声明部分 - undefined
showName();
console.log(myname);
+ name = 'jsliang'; // 赋值部分
- var myname = 'jsliang';
- function showName() {
-  console.log('函数 showName 被执行');
- }
```

所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的 “行为”。

变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 `undefined`。

既然如此，那么下面代码输出什么？

```js
showName();
var showName = function() {
  console.log(2);
}
function showName() {
  console.log(1);
}
```

答案：1

变量提升会产生什么问题：

1. 变量容易在不被察觉的情况下被覆盖掉
2. 本应销毁的变量没有被销毁

## <a name="chapter-night" id="chapter-night"></a>九 JavaScript 栈溢出

> [返回目录](#chapter-one)

JavaScript 中有很多函数，经常会出现在一个函数中调用另外一个函数的情况，调用栈就是用来管理函数调用关系的一种数据结构。

### <a name="chapter-night-one" id="chapter-night-one"></a>9.1 函数调用

> [返回目录](#chapter-one)

```js
var a = 2;

function add() {
  var b = 10;
  return a + b;
}

add();
```

在这段代码中，首先创建 `add` 函数，然后调用该函数，进行求和。

| 全局执行上下文 |  |
| --- | --- |
| 变量环境 | 词法环境 |
| a = undefined |  |
| add = function () { ... } |  |

### <a name="chapter-night-two" id="chapter-night-two"></a>9.2 栈

> [返回目录](#chapter-one)

后进先出，简单来说，一个数组：

```js
var a = [];
a.push(1);
a.push(2);
a.push(3);
console.log(a); // [1, 2, 3]
```

这个步骤叫压栈，就是将数字不停地塞进数组尾部。

```js
a.pop(); // 3
a.pop(); // 2
a.pop(); // 1
console.log(a); []
```

这个步骤叫出栈，就是将数字不停地从数组尾部取出。

栈就类似于叠罗汉，压栈就是先叠第一层，再叠第二层……出栈就是先出最高那层，再出倒数第二层……

### <a name="chapter-night-three" id="chapter-night-three"></a>9.3 调用栈

> [返回目录](#chapter-one)

JavaScript 引擎就是利用栈这种结构管理执行上下文的。

在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。

我们拿一个递归函数来看：

```js
const recursion = (num) => {
  if (num === 1) {
    return 1;
  }
  recursion(num - 1);
};
recursion(3);
```

在这里，先执行 `recursion(3)`，再执行 `recursion(2)`，最后执行 `recursion(1)`，这是压栈步骤。

接着 `recursion(1)` 执行完毕，消除这个；`recursion(2)` 执行完毕，最后 `recursion(3)` 执行完毕。

这种机制就是调用栈。

### <a name="chapter-night-four" id="chapter-night-four"></a>9.4 栈溢出

> [返回目录](#chapter-one)

假如这时候，我们将代码变一变：

```js
const recursion = (num) => {
  if (num === 1) {
    return 1;
  }
  if (num === 2) {
    return 2;
  }
  return recursion(num - 1) + recursion(num - 2);
};
console.log(recursion(100));
```

JavaScript 的调用栈是有大小的，入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，这种错误就是栈溢出。

**jsliang** 运行上面这行代码，放了一会手提就疯狂运转了！

所以有时候看到：超过了最大栈调用大小（Maximum call stack size exceeded），你应该知道是什么问题了。

## <a name="chapter-ten" id="chapter-ten"></a>十 var 的缺陷和 let、const

> [返回目录](#chapter-one)

由于 JavaScript 存在变量提升这种特性，从而导致了很多与直觉不符的代码，这也是 JavaScript 的一个重要设计缺陷。

虽然 ECMAScript6（以下简称 ES6）已经通过引入块级作用域并配合 `let`、`const `关键字，来避开了这种设计缺陷，但是由于 JavaScript 需要保持向下兼容，所以变量提升在相当长一段时间内还会继续存在。

### <a name="chapter-ten-one" id="chapter-ten-one"></a>10.1 作用域

> [返回目录](#chapter-one)

作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

ES5 时候的作用域只有两种：

* **全局作用域**：全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
* **函数作用域**：函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

ES6 有块级作用域的定义：

* **块级作用域**：使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个 `{}` 都可以被看作是一个块级作用域。

```js
// if块
if(1){}

// while 块
while(1){}

// 函数块
function foo(){}
 
// for 循环块
for(let i = 0; i<100; i++){}

// 单独一个块
{}
```

块级作用域其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。

### <a name="chapter-ten-two" id="chapter-ten-two"></a>10.2 题目

> [返回目录](#chapter-one)

```js
function foo(){
  var a = 1;
  let b = 2;
  {
    let b = 3;
    var c = 4;
    let d = 5;
    console.log(a);
    console.log(b);
  }
  console.log(b);
  console.log(c);
  console.log(d);
}   
foo();
```

求打印顺序。

答：1 -> 3 -> 2 -> 4 -> 报错

## <a name="chapter-eleven" id="chapter-eleven"></a>十一 作用域链和闭包

> [返回目录](#chapter-one)

### <a name="chapter-eleven-one" id="chapter-eleven-one"></a>11.1 作用域链和词法作用域

> [返回目录](#chapter-one)

```js
function bar() {
  console.log(myName);
}
function foo() {
  var myName = "jsliang2";
  bar();
}
var myName = "jsliang1";
foo();
```

这段代码输出 `jsliang1`，为什么？

讲解这个问题之前，我们看一下词法作用域：

```js
function foo() {
  var myName = 'jsliang2';
  function bar() {
    console.log(myName);
  }
};
var myName = 'jsliang1';
foo();
```

像这段代码，它的词法作用域链的顺序是：bar 函数作用域 -> foo 函数作用域 -> 全局作用域。

所以在 `bar()` 中查找 `myName`，没找到就查找 `foo()` 的，于是返回 `jsliang2`。

我们回过头来：

```js
function bar() {
  console.log(myName);
}
function foo() {
  var myName = "jsliang2";
  bar();
}
var myName = "jsliang1";
foo();
```

这段代码的词法作用域链是：foo 函数作用域 -> 全局作用域；bar 函数作用域 -> 全局作用域。

所以在 `foo()` 中调用 `bar()`，而 `bar()` 找不到自身的，会去找全局作用域的。

所以什么是 **作用域链** 和 **词法作用域**：

* **作用域链**：从当前函数开始，逐步往全局作用域查找，形成的这一条查找链就是作用域链。
* **词法作用域**：作用域是有代码中函数声明的位置决定的，它是静态的作用域，能够预测代码在执行过程中查找标识符。

**词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。**

### <a name="chapter-eleven-two" id="chapter-eleven-two"></a>11.2 块级作用域

> [返回目录](#chapter-one)

```js
function bar() {
  console.log(myName);
}
function foo() {
  let myName = "jsliang2";
  bar();
}
var myName = "jsliang1";
foo();
```

那么，现在我们将 `jsliang2` 的 `myName` 变量定义为 `let`，会输出什么呢？

答案是：`jsliang1`，这是拦不住的。

### <a name="chapter-eleven-three" id="chapter-eleven-three"></a>11.3 闭包

> [返回目录](#chapter-one)

```js
function foo() {
  let i = 1;
  return function() {
    i++;
    console.log(i);
  }
}
let f = foo();
f(); // 2
f(); // 3
```

在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量。

当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了。

但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。

### <a name="chapter-eleven-four" id="chapter-eleven-four"></a>11.4 如何回收闭包

> [返回目录](#chapter-one)

闭包使用不正确，容易造成内存泄漏：

如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

因此需要注意一个原则：**如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。**

### <a name="chapter-eleven-five" id="chapter-eleven-five"></a>11.5 小结

> [返回目录](#chapter-one)

* 首先，介绍了什么是作用域链，我们把通过作用域查找变量的链条称为作用域链；作用域链是通过词法作用域来确定的，而词法作用域反映了代码的结构。
* 其次，介绍了在块级作用域中是如何通过作用域链来查找变量的。
* 最后，又基于作用域链和词法环境介绍了到底什么是闭包。

## <a name="chapter-twelve" id="chapter-twelve"></a>十二 this

> [返回目录](#chapter-one)

作用域链和 `this` 是两套不同的系统，它们之间基本没太多联系。

`this` 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 `this`。

执行上下文分为 3 种：

* 全局执行上下文
* 函数执行上下文
* `eval` 执行上下文

所以 `this` 对应的也只有这 3 种。

> 注意这里是浏览器中的 `this`，和 Node 中的 `this` 是不一样的。

### <a name="chapter-twelve-one" id="chapter-twelve-one"></a>12.1 全局执行上下文中的 this

> [返回目录](#chapter-one)

在 Chrome 控制台中输入：`this`，你会看到答案：

```js
Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}
```

全局执行上下文中的 `this` 是指向 `Window` 的。

```js
function foo() {
  console.log(this);
}
foo();
```

这段代码也是输出 `Window`，为什么？

记住 `this` 就是谁调用它就指向谁。

我们在全局对象中调用 `foo`，实际上就相当于 `window.foo()` 的一个调用，那么就是指向 `Window`。

> 在执行上面代码之后，其实小伙伴可以在 Chrome 的控制台输入 `window`，会看到里面存在 `foo()` 方法。

### <a name="chapter-twelve-two" id="chapter-twelve-two"></a>12.2 函数执行上下文中的 this

> [返回目录](#chapter-one)

在上面我们知道，一般的调用方法，是调用 `window` 上的方法。

那怎么获取当前函数的 `this` 呢？

#### <a name="chapter-twelve-two-one" id="chapter-twelve-two-one"></a>12.2.1 通过 call/bind/apply 改变 this

> [返回目录](#chapter-one)

```js
this.myName = 'jsliang';
let foo = function() {
  this.myName = 'zhazhaliang';
}
foo();
console.log(window.myName); // 输出啥？
console.log(foo.myName); // 输出啥？
```

这时候的 `this` 指向 `window`，所以输出结果为；

* zhazhaliang
* undefined

通过 `call` 绑定后：

```js
this.myName = 'jsliang';
let foo = function() {
  this.myName = 'zhazhaliang';
}
foo.call(foo);
console.log(window.myName); // 输出啥？
console.log(foo.myName); // 输出啥？
```

输出结果为：

* jsliang
* zhazhaliang

#### <a name="chapter-twelve-two-two" id="chapter-twelve-two-two"></a>12.2.2 通过对象调用方法设置

> [返回目录](#chapter-one)

使用对象来调用其内部的一个方法，该方法的 `this` 是指向对象本身的。

> 案例 1

```js
let myObj = {
  name: 'jsliang',
  showThis: function() {
    console.log(this.name);
  },
};
myObj.showThis(); // 输出啥？
```

输出 `jsliang`。

当然，我们要有自知之明：

> 案例 2

```js
let myObj = {
  myName: 'jsliang',
  showThis: function() {
    console.log(this.myName);
  },
};
let foo = myObj.showThis;
foo(); // 输出啥？
```

这时候它又变成 `window` 指向了，相当于：

> 案例 2 变型

```js
let foo = function() {
  console.log(this.myName);
}
foo();
```

毋庸置疑输出 `undefined`。

> 案例 3

```js
let myObj = {
  name: 'jsliang',
  showThis: function() {
    console.log(this.name);
  },
};
let foo = myObj.showThis;
foo(); // 输出啥？
```

一般来说，这段代码输出应该是 `undefined`。

但是，这里需要注意的是，`window.name` 是当前 `window` 的名称，它是 `window.open()` 打开新网页这个方法的第二个参数的值。

所以这里输出的 `windwo.name` 是个空值 `''`，或者当前存在的 `window` 的名称。

> index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>jsliang</title>
</head>
<body>
  <button class="btn">打开新网页</button>

  <script>
    (function() {
      const btn = document.querySelector('.btn');
      btn.onclick = function() {
        window.open('index.html', 'jsliang 的网页');
      }
    })()
  </script>
</body>
</html>
```

在新打开的网页中的控制台，输入 `window.name`，获取 `jsliang 的网页`。

结论：

* 在全局环境中调用一个函数，函数内部的 `this` 指向的是全局变量 `window`。
* 通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 `this` 指向对象本身。

#### <a name="chapter-twelve-two-three" id="chapter-twelve-two-three"></a>12.2.3 通过构造函数中设置

> [返回目录](#chapter-one)

```js
this.name = 'jsliang';
let Foo = function() {
  this.name = 'zhazhaliang';
}
let foo = new Foo();
console.log(foo.name); // 输出啥？
console.log(window.name); // 输出啥？
```

答案是：

* zhazhaliang
* jsliang

在将这个答案的缘故之前，我们看下 `new Foo()` 中，JavaScript 引擎做了什么事：

* 首先创建一个空对象 `tempObj = {}`。
* 接着调用 `Foo.apply` 方法，将 `tempObj` 作为 `apply` 方法的参数，这样当 `Foo` 的执行上下文创建时，它的 `this` 就指向 `tempObj` 对象。
* 然后执行 `Foo` 函数，此时的 `Foo` 函数执行上下文中的 `this` 指向了 `tempObj` 对象。
* 最后返回 `tempObj` 对象。

```js
function myNew(func, ...args) {
  const tempObj = {};
  func.apply(tempObj, args);
  return tempObj;
}

this.name = 'jsliang';
let Foo = function(name, age) {
  this.name = name;
  this.age = age;
}
let foo = myNew(Foo, 'zhazhaliang', 25);
console.log(foo.name); // 输出啥？
console.log(foo.age); // 输出啥？
console.log(window.name); // 输出啥？
```

如上，我们可以看到此时 `this` 是属于 `tempObj` 的，绑定到 `foo` 上去了，从而获取到：

* zhazhaliang
* 25
* jsliang

当然，了解到这里，我们还是完善下 `new` 这个手写方法：

```js
function myNew(func, ...args) {
  // 1. 判断方法体
  if (typeof func !== 'function') {
    throw '第一个参数必须是方法体';
  }

  // 2. 创建新对象
  const obj = {};

  // 3. 这个对象的 __proto__ 指向 func 这个类的原型对象
  // 即实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性
  obj.__proto__ = Object.create(func.prototype);
  // 为了兼容 IE 可以让步骤 2 和 步骤 3 合并
  // const obj = Object.create(func.prototype);

  // 4. 通过 apply 绑定 this 执行并且获取运行后的结果
  let result = func.apply(obj, args);
  
  // 5. 如果构造函数返回的结果是引用数据类型，则返回运行后的结果
  // 否则返回新创建的 obj
  const isObject = typeof result === 'object' && result !== null;
  const isFunction = typeof result === 'function';
  return isObject || isFunction ? result : obj;
}

// 测试
function Person(name) {
  this.name = name;
  return function() { // 用来测试第 5 点
    console.log('返回引用数据类型');
  };
}
// 用来测试第 2 点和第 3 点
Person.prototype.sayName = function() {
  console.log(`My name is ${this.name}`);
}
const me = myNew(Person, 'jsliang'); // 用来测试第 4 点
me.sayName(); // My name is jsliang
console.log(me); // Person {name: 'jsliang'}

// 用来测试第 1 点
// const you = myNew({ name: 'jsliang' }, 'jsliang'); // 报错：第一个参数必须是方法体
```

### <a name="chapter-twelve-three" id="chapter-twelve-three"></a>12.3 this 设计缺陷和应对方案

> [返回目录](#chapter-one)

* **嵌套函数中的 `this` 不会从外层函数中继承**

```js
var myObj = {
  myName: "jsliang", 
  showThis: function(){
    console.log(this.myName); // 输出啥？
    function bar(){
      console.log(this.myName); // 输出啥？
    }
    bar();
  },
};
myObj.showThis();
```

答案是：

1. jsliang
2. undefined

**解决方法一：通过 `that` 控制 `this` 指向**

```js
var myObj = {
  myName: "jsliang", 
  showThis: function(){
    console.log(this.myName); // 输出啥？
    let that = this;
    function bar(){
      console.log(that.myName); // 输出啥？
    }
    bar();
  },
};
myObj.showThis();
```

这样都输出 `jsliang` 了。

**解决方法二：通过 ES6 的箭头函数解决问题**

```js
var myObj = {
  myName: "jsliang", 
  showThis: function(){
    console.log(this.myName); // 输出啥？
    const bar = () => {
      console.log(this.myName); // 输出啥？
    }
    bar();
  },
};
myObj.showThis();
```

这是因为 ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 `this` 取决于它的外部函数，即谁调用它 `this` 就继承自谁。

* **普通函数中 `this` 指向全局对象 `window`**

在实际工作中，我们并不希望函数执行上下文中的 `this` 默认指向全局对象，因为这样会打破数据的边界，造成一些误操作。

如果要让函数执行上下文中的 `this` 指向某个对象，最好的方式是通过 `call` 方法来显示调用。

这个问题可以通过设置 JavaScript 的 **严格模式** 来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 `this` 值是 `undefined`，这就解决上面的问题了。

### <a name="chapter-twelve-four" id="chapter-twelve-four"></a>12.4 小结

> [返回目录](#chapter-one)

* 当函数作为对象的方法调用时，函数中的 `this` 就是该对象；
* 当函数被正常调用时，在严格模式下，`this` 值是 `undefined`，非严格模式下 `this` 指向的是全局对象 `window`；
* 嵌套函数中的 `this` 不会继承外层函数的 `this` 值。

思考：

```js
let userInfo = {
  name: 'jsliang',
  age: 25,
  sex: 'male',
  updateInfo: function(){
    // 模拟 XMLHttpRequest 请求延时
    setTimeout(function(){
      this.name = "zhazhaliang"
      this.age = 30;
      this.sex = 'female';
    }, 1000);
  },
};

userInfo.updateInfo();
```

解决这里的 `this` 指向问题，求得最终结果：

```js
{
  name: "zhazhaliang",
  age: 30,
  sex: "female",
  updateInfo: function(),
}
```

答案：`setTimeout(() => {})` 即可。

## <a name="chapter-thirteen" id="chapter-thirteen"></a>十三 JavaScript 内存机制

> [返回目录](#chapter-one)

JavaScript 是一种弱类型、动态的语言：

* 弱类型，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。
* 动态，意味着你可以使用同一个变量保存不同类型的数据。

### <a name="chapter-thirteen-one" id="chapter-thirteen-one"></a>13.1 JavaScript 数据类型

> [返回目录](#chapter-one)

JavaScript 的数据类型有 8 种：

* `Boolean`
* `Null`
* `Undefined`
* `Number`
* `String`
* `Symbol`
* `BigInt`
* `Object`

其中 `Object` 为引用类型，其他为原始类型。

怎么区分呢？我们看一份代码：

```js
function foo() {
  var a = 1;
  var b = a;
  a = 2;
  console.log(a); // 输出啥？
  console.log(b); // 输出啥？
  
  var c = { name: 'jsliang' };
  var d = c;
  c.name = 'zhazhaliang';
  console.log(c); // 输出啥？
  console.log(d); // 输出啥？
};
foo();
```

输出结果依序是：

```js
2
1
{ name: 'zhazhaliang' }
{ name: 'zhazhaliang' }
```

原始类型的数据值都是直接保存在 “栈” 中的，引用类型的值是存放在 “堆” 中的。

上面代码中 `a` 和 `b` 是存储到栈中的，所以你修改 `a` 那就是修改 `a`，而不会影响到 `b`。

但是 `c` 和 `d` 都是存储到堆中的，它们都引用了同一个索引地址，你可以理解为它们引用了数组的同一个下标索引。

所以当 `c` 修改这个下标索引的值后，那么 `d` 也会对应着修改。

### <a name="chapter-thirteen-two" id="chapter-thirteen-two"></a>13.2 为什么要区分堆和栈

> [返回目录](#chapter-one)

这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。

在上面的 `foo()` 函数调用完毕之后，移动当前执行上下文的指针到全局执行上下文，`foo()` 函数执行上下文被回收。

所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。

而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。

### <a name="chapter-thirteen-three" id="chapter-thirteen-three"></a>13.3 闭包在内存中

> [返回目录](#chapter-one)

```js
function foo() {
  let i = 1;
  return function() {
    i++;
    console.log(i);
  }
}
let f = foo();
f(); // 2
f(); // 3
```

1. JavaScript 引擎执行到 `foo()` 函数时，首先会编译，创建一个空执行上下文。
2. 编译过程中，发现内部有个 `function()` 调用了 `i` 变量，因为是内部函数调用外部函数，所以 JavaScript 判断这是一个闭包，于是堆空间创建一个 `closure(foo)` 的对象（这是一个内部对象，用户无法通过 JavaScript 访问），用来保存 `i` 变量。

总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。

## <a name="chapter-fourteen" id="chapter-fourteen"></a>十四 垃圾回收

> [返回目录](#chapter-one)

原始数据类型是存储在栈空间中的，引用类型的数据是存储在堆空间中的。

不过有些数据被使用之后，可能就不再需要了，我们把这种数据称为垃圾数据。

如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要对这些垃圾数据进行回收，以释放有限的内存空间。

垃圾回收策略分为 **手动回收** 和 **自动回收** 两种：

* 手动回收：C/C++ 语言可以通过 `free()` 这些代码来决定何时分配内存、何时销毁内存。
* 自动回收：JavaScript、Python、Java 等产生的垃圾数据是由垃圾回收器来释放的。

### <a name="chapter-fourteen-one" id="chapter-fourteen-one"></a>14.1 栈垃圾回收

> [返回目录](#chapter-one)

当函数执行结束，JavaScript 引擎通过向下移动 ESP 指针（记录调用栈当前执行状态的指针），来销毁该函数保存在栈中的执行上下文（变量环境、词法环境、this、outer）。

如果有代码：

```js
function foo(){
  var a = 1;
  var b = { name: 'jsliang' };
  function showName(){
    var c = 2;
    var d = { name: 'zhazhaliang' };
  }
  showName();
}
foo();
```

| 调用栈 |
| --- |
| showName 函数执行上下文 |
| foo 函数执行上下文 |
| 全局执行上下文 |

1. 执行到 `showName` 函数的时候，创建 `showName` 函数的执行上下文，并将 `showName` 函数的执行上下文压入栈中。
2. 以此同时，我们会有一个记录当前执行状态的指针（称为 ESP），指向调用栈中 `showName` 函数的执行上下文，表示当前正在执行 `showName` 函数。
3. 当 `showName` 函数执行完毕，函数执行流程进入 `foo` 函数，这时候 ESP 就下移到 `foo` 函数的执行上下文。这个下移操作就是销毁 `showName` 函数执行上下文的过程。

如果 `showName` 函数下面还调用了另一个函数，那么它会覆盖 `showName` 函数的内容，用来存放另一个函数的执行上下文。

就是说：当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁保存栈中的执行上下文。

### <a name="chapter-fourteen-two" id="chapter-fourteen-two"></a>14.2 堆垃圾回收

> [返回目录](#chapter-one)

在上面，我们将栈中的垃圾通过 ESP 进行回收了：

```js
function foo(){
  var a = 1;
  var b = { name: 'jsliang' };
  function showName(){
    var c = 2;
    var d = { name: 'zhazhaliang' };
  }
  showName();
}
foo();
```

但是，里面的 `b` 和 `d` 其实是依旧存在于堆中的。

要回收对重的垃圾数据，就需要 JavaScript 中的垃圾回收器了。

### <a name="chapter-fourteen-three" id="chapter-fourteen-three"></a>14.3 新生代和老生代

> [返回目录](#chapter-one)

代际假说特点：

1. 大部分对象存活时间很短
2. 不被销毁的对象，会活的更久

这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。

V8 中会把堆分为 **新生代** 和 **老生代** 两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。

新生区的容量没有老生区那么大，所以 V8 分别使用 2 个不同的垃圾回收器，来高效实施垃圾回收：

* **副垃圾回收器**。主要负责新生代的垃圾回收。
* **主垃圾回收器**。主要负责老生代的垃圾回收。

#### <a name="chapter-fourteen-three-one" id="chapter-fourteen-three-one"></a>14.3.1 新生代 - 副垃圾回收器

> [返回目录](#chapter-one)

算法：**Scavenge 算法**

原理：

1. 把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。
2. 新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。
3. 先对对象区域中的垃圾做标记，标记完成之后，把这些存活的对象复制到空闲区域中
4. 完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。

对象晋升策略：**经过两次垃圾回收依然还存活的对象，会被移动到老生区中。**

#### <a name="chapter-fourteen-three-two" id="chapter-fourteen-three-two"></a>14.3.2 老生代 - 主垃圾回收器

> [返回目录](#chapter-one)

* 算法：标记 - 清除（Mark-Sweep）算法
* 原理：

1. 标记：标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。
2. 清除：将垃圾数据进行清除。

对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存。

这时候就需要标记整理。

---

* 算法：标记 - 整理（Mark-Compact）算法
* 原理：

1. 标记：和标记 - 清除的标记过程一样，从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素标记为活动对象。
2. 整理：让所有存活的对象都向内存的一端移动
3. 清除：清理掉端边界以外的内存

### <a name="chapter-fourteen-four" id="chapter-fourteen-four"></a>14.4 全停顿

> [返回目录](#chapter-one)

由于 JavaScript 是单线程的，所以一旦执行垃圾回收算法，那正在执行的 JavaScript 脚本需要暂停下来，等垃圾回收完毕之后再恢复脚本执行。

这种行为叫 **全停顿（Stop-The-World）**。

如果堆中的数据较多，那么回收需要时间，会造成页面卡顿状态，所以为了降低这个卡顿，V8 将标记过程分为一个一个子标记过程，同时垃圾回收标记和 JavaScript 应用逻辑交替进行。

* 优化算法：增量标记（Incremental Marking）算法
* 原理：

1. 为了降低老生代的垃圾回收而造成的卡顿
2. V8 把一个完整的垃圾回收任务拆分为很多小的任务
3. 让垃圾回收标记和 JavaScript 应用逻辑交替进行

## <a name="chapter-fifteen" id="chapter-fifteen"></a>十五 V8 如何执行一段 JavaScript 代码

> [返回目录](#chapter-one)

了解 V8 执行机制，从底层了解 JavaScript，深入理解语言转换器 Babel、语法检查工具 ESLint、前端框架 Vue 和 React 的一些底层实现机制。

### <a name="chapter-fifteen-one" id="chapter-fifteen-one"></a>15.1 编译器和解释器

> [返回目录](#chapter-one)

之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码。

所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。按语言的执行流程，可以把语言划分为编译型语言和解释型语言。

编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。

解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。

* 编译器：
  * **源代码** 通过 **词法/语法分析** 转成 **AST**；
  * **AST** 通过 **词义分析** 转成 **中间代码**；
  * **中间代码** 通过 **代码优化** 转成 **二进制代码**；
  * **二进制代码** 直接执行返回 **执行结果**；
* 解释器
  * **源代码** 通过 **词法/语法分析** 转成 **AST**；
  * **AST** 通过 **词义分析** 转成 **字节码**；
  * **字节码** 解释执行返回 **执行结果**；

### <a name="chapter-fifteen-two" id="chapter-fifteen-two"></a>15.2 V8 如何执行一段 JavaScript 代码

> [返回目录](#chapter-one)

* **生成抽象语法树（AST）和执行上下文**

AST 的结构和代码的结构非常相似，可以把 AST 看成代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。

AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。

Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。

除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。

AST 解析过程：

1. 第一阶段是分词（tokenize），又称为词法分析，其作用是将一行行的源码拆解成一个个 token。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串。
2. 第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。

* **生成字节码**

有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。

字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。

* **执行代码**

通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。

到了这里，相信你已经发现了，解释器 Ignition 除了负责生成字节码之外，它还有另外一个作用，就是解释执行字节码。

在 Ignition 执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码。

然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。

## <a name="chapter-sixteen" id="chapter-sixteen"></a>十六 消息队列和事件循环

> [返回目录](#chapter-one)

前面我们讲到了每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。

要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是消息队列和事件循环系统。

* 如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务
* 要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统
* 如果要接收其他线程发送过来的任务，就需要引入消息队列
* 如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程
* 消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务

## <a name="chapter-seventeen" id="chapter-seventeen"></a>十七 setTimeout

> [返回目录](#chapter-one)

浏览器页面是由消息队列和事件循环系统来驱动的。

`setTimeout`：一个定时器，用来指定某个函数在多少毫秒之后执行。返回一个整数，表示定时器的编号。可以通过 `clearTimeout` 来清除这个定时器。

```js
const a = setTimeout(() => {
  console.log('a');
}, 10000);

console.log(a);

setTimeout(() => {
  clearTimeout(a);
}, 1000);
```

这段代码表示设置一个定时器 `a`，它在 10 秒后触发。

但是我设置了一个定时器在 1 秒后触发，并清空定时器 `a`，导致它不再触发。

### <a name="chapter-seventeen-one" id="chapter-seventeen-one"></a>17.1 浏览器实现 setTimeout

> [返回目录](#chapter-one)

渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。

* 当接收到 HTML 文档数据，渲染引擎就会将 “解析 DOM” 事件添加到消息队列中
* 当用户改变了 Web 页面的窗口大小，渲染引擎就会将 “重新布局” 的事件添加到消息队列中
* 当触发了 JavaScript 引擎垃圾回收机制，渲染引擎会将 “垃圾回收” 任务添加到消息队列中
* 如果要执行一段异步 JavaScript 代码，也是需要将执行任务添加到消息队列中。

要执行一段异步任务，需要先将任务添加到消息队列中。

不过通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，所以为了保证回调函数能在指定时间内执行，你不能将定时器的回调函数直接添加到消息队列中。

在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。

所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。

当 JavaScript 调用 `setTimeout` 设置回调函数的时候：

1. 渲染进程会创建一个回调任务。该回调任务包含回调函数 showName、当前发起时间、延迟执行时间。
2. 创建好回调任务后，将该任务添加到延迟执行队列中。

### <a name="chapter-seventeen-two" id="chapter-seventeen-two"></a>17.2 使用 setTimeout 注意事项

> [返回目录](#chapter-one)

1. 如果当前任务执行时间过久，会影响定时器任务的执行。中间具有不确定性，可能会更久后才执行。
2. 如果 `setTimeout` 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒。
3. 未激活的页面，`setTimeout` 执行最小间隔是 1000 毫秒。如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。
4. 延时执行时间有最大值。
5. 使用 `setTimeout` 设置的回调函数中的 this 不符合直觉。

### <a name="chapter-seventeen-three" id="chapter-seventeen-three"></a>17.3 小结

> [返回目录](#chapter-one)

* 首先，为了支持定时器的实现，浏览器增加了延时队列。
* 其次，由于消息队列排队和一些系统级别的限制，通过 `setTimeout` 设置的回调任务并非总是可以实时地被执行，这样就不能满足一些实时性要求较高的需求了。
* 最后，在定时器中使用过程中，还存在一些陷阱，需要你多加注意。

## <a name="chapter-eighteen" id="chapter-eighteen"></a>十八 XMLHttpRequest

> [返回目录](#chapter-one)

只需要通过 XMLHttpRequest 请求服务器提供的接口，就可以获取到服务器的数据。

在深入 XMLHttpRequest 之前，先了解 **同步回调** 和 **异步回调** 这两个概念，更加深刻地理解 WebAPI 是怎么工作的。

### <a name="chapter-eighteen-one" id="chapter-eighteen-one"></a>18.1 回调函数

> [返回目录](#chapter-one)

将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。

```js
const debounce = (fn) => {
  // 同步回调
  fn();

  // 异步回调
  setTimeout(() => {
    fn();
  }, 1000);
}

const sayHello = () => {
  console.log('123');
}

debounce(sayHello);
```

如上，有 `sayHello` 和 `debounce` 方法，在 `debounce` 执行后调用 `sayHello` 这个回调函数。

如果这个回调函数是在主任务返回之前执行的，那就是 **同步回调**。

如果是在主任务返回之后执行的，有延迟，那就是 **异步回调**。

### <a name="chapter-eighteen-two" id="chapter-eighteen-two"></a>18.2 XMLHttpRequest 运作机制

> [返回目录](#chapter-one)

1. 创建 `XMLHttpRequest` 对象。`let xhr = new XMLHttpRequest()`
2. 为 `xhr` 对象注册回调函数。
   1. `ontimeout`：监控超时请求
   2. `onerror`：监控出错信息
   3. `onreadystatechange`：监控后台请求过程中的状态
3. 配置基础的请求信息。
   1. 通过 `open` 配置基础请求信息，例如请求地址、请求方法和请求方式
   2. 通过 `xhr` 内部属性配置其他可选信息，例如 `xhr.timeout = 3000` 配置超时时间等
4. 发起请求。`xhr.send()`

```js
function GetWebData(URL) {
  /**
   * 1:新建XMLHttpRequest请求对象
   */
  let xhr = new XMLHttpRequest()

  /**
   * 2:注册相关事件回调处理函数 
   */
  xhr.onreadystatechange = function () {
    switch (xhr.readyState) {
      case 0: //请求未初始化
        console.log("请求未初始化")
        break;
      case 1://OPENED
        console.log("OPENED")
        break;
      case 2://HEADERS_RECEIVED
        console.log("HEADERS_RECEIVED")
        break;
      case 3://LOADING  
        console.log("LOADING")
        break;
      case 4://DONE
        if (this.status == 200 || this.status == 304) {
          console.log(this.responseText);
        }
        console.log("DONE")
        break;
    }
  }

  xhr.ontimeout = function (e) { console.log('ontimeout') }
  xhr.onerror = function (e) { console.log('onerror') }

  /**
   * 3:打开请求
   */
  xhr.open('Get', URL, true);//创建一个Get请求,采用异步


  /**
   * 4:配置参数
   */
  xhr.timeout = 3000 //设置xhr请求的超时时间
  xhr.responseType = "text" //设置响应返回的数据格式
  xhr.setRequestHeader("X_TEST", "time.geekbang")

  /**
   * 5:发送请求
   */
  xhr.send();
}
```

请求流程：

1. 渲染进程会将请求发送给网络进程
2. 网络进程负责资源的下载
3. 等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程
4. 渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中
5. 等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数

### <a name="chapter-eighteen-three" id="chapter-eighteen-three"></a>18.3 XMLHttpRequest 使用过程中的 “坑”

> [返回目录](#chapter-one)

1. 跨域问题
2. HTTPS 混合内容的问题

## <a name="chapter-nighteen" id="chapter-nighteen"></a>十九 宏任务和微任务

> [返回目录](#chapter-one)

随着浏览器的应用领域越来越广泛，消息队列中这种粗时间颗粒度的任务已经不能胜任部分领域的需求，所以又出现了一种新的技术——微任务。

微任务可以在实时性和效率之间做一个有效的权衡。

微任务已经被广泛地应用，基于微任务的技术有 MutationObserver、Promise 以及以 Promise 为基础开发出来的很多其他的技术。

### <a name="chapter-nighteen-one" id="chapter-nighteen-one"></a>19.1 宏任务

> [返回目录](#chapter-one)

页面中的大部分任务都是在主线程上执行的，这些任务包括了：

* 渲染事件（如解析 DOM、计算布局、绘制）；
* 用户交互事件（如鼠标点击、滚动页面、放大缩小等）；
* JavaScript 脚本执行事件；
* 网络请求完成、文件读写完成事件。

为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。

然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。

### <a name="chapter-nighteen-two" id="chapter-nighteen-two"></a>19.2 微任务

> [返回目录](#chapter-one)

宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了。

异步回调的两种方式：

* 把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。`setTimeout` 或者 `XMLHttpRequest` 等。
* 在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。例如 `Promise.then()`。

微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。

当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个微任务队列。

这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。

不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。

产生微任务：

1. 使用 `MutationObserver` 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。
2. 使用 `Promise`，当调用 `Promise.resolve()` 或者 `Promise.reject()` 的时候，也会产生微任务。

### <a name="chapter-nighteen-three" id="chapter-nighteen-three"></a>19.3 监听 DOM 变化方法演变

> [返回目录](#chapter-one)

MutationObserver 是用来监听 DOM 变化的一套方法，而监听 DOM 变化一直是前端工程师一项非常核心的需求。

早期页面并没有提供对监听的支持，所以那时要观察 DOM 是否变化，唯一能做的就是轮询检测，比如使用 `setTimeout` 或者 `setInterval` 来定时检测 DOM 是否有改变。

这种方式简单粗暴，但是会遇到两个问题：

* 如果时间间隔设置过长，DOM 变化响应不够及时；
* 反过来如果时间间隔设置过短，又会浪费很多无用的工作量去检查 DOM，会让页面变得低效。

所以 2000 年引入了 `Mutation Event`，`Mutation Event` 采用了观察者的设计模式，当 DOM 有变动时就会立刻触发相应的事件，这种方式属于同步回调。

采用 `Mutation Event` 解决了实时性的问题，因为 DOM 一旦发生变化，就会立即调用 JavaScript 接口。

但也正是这种实时性造成了严重的性能问题，因为每次 DOM 变动，渲染引擎都会去调用 JavaScript，这样会产生较大的性能开销。

所以为了解决了 `Mutation Event` 由于同步调用 JavaScript 而造成的性能问题，从 DOM4 开始，推荐使用 `MutationObserver` 来代替 `Mutation Event`。

改进点：

`MutationObserver` 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。这样即使频繁地操纵 DOM，也不会对性能造成太大的影响。

如果采用 setTimeout 创建宏任务来触发回调的话，那么实时性就会大打折扣，因为上面我们分析过，在两个任务之间，可能会被渲染进程插入其他的事件，从而影响到响应的实时性。

这时候，微任务就可以上场了，在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了。

所以 `MutationObserver` 采用了“异步 + 微任务”的策略。

1. 通过异步操作解决了同步操作的性能问题
2. 通过微任务解决了实时性的问题

## <a name="chapter-twenty" id="chapter-twenty"></a>二十 Promise

> [返回目录](#chapter-one)

DOM/BOM API 中新加入的 API 大多数都是建立在 Promise 上的，而且新的前端框架也使用了大量的 Promise。

Promise 解决的问题：

1. 异步编程的问题：代码逻辑不连续。例如 `setTimeout` 有个异步回调，当嵌套多了就有回调地狱，影响我们的阅读理解。
2. 封装异步代码，让处理流程变得线性。

通过 Promise 封装 Ajax：

```js
// XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。
const promiseAjax = (url) => {
  return new Promise((resolve, reject) => {
    const handler = () => {
      // 判断请求状态码
      if (this.readyState !== 4) {
        return;
      }

      // 请求的响应状态
      if (this.state === 200) {
        resolve(this.response);
      } else {
        // 完整的响应状态文本（例如，"200 OK"）
        reject(new Error(this.statusText));
      }
    };

    const client = new XMLHttpRequest();
    client.open('GET', url); // 初始化一个请求。
    client.onreadystatechange = handler; // 当 readyState 属性变化时，调用 EventHandler
    client.responseType = 'json'; // 一个用于定义响应类型的枚举值（enumerated value）。
    client.setRequestHeader('Accept', 'application/json'); // 设置 HTTP 请求头的值。必须在 open() 之后、send() 之前调用 setRequestHeader() 方法。
    client.send(); // 发送请求。
  });
};

promiseAjax('https://www.baidu.com').then((json) => {
  console.log('成功：', json);
}).catch((error) => {
  console.error('失败：', error);
})
```

## <a name="chapter-twenty-one" id="chapter-twenty-one"></a>二十一 async/await

> [返回目录](#chapter-one)

使用 `promise.then` 也是相当复杂，虽然整个请求流程已经线性化了，但是代码里面包含了大量的 `then` 函数，使得代码依然不是太容易阅读。

基于这个原因，ES7 引入了 `async`/`await`，这是 JavaScript 异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰。

```js

async function foo(){
  try {
    let response1 = await fetch('https://www.baidu.com');
    console.log('response1');
    console.log(response1);

    let response2 = await fetch('https://www.baidu.com');
    console.log('response2');
    console.log(response2);

  } catch(err) {
    console.error(err)
  }
}
foo();
```

### <a name="chapter-twenty-one-one" id="chapter-twenty-one-one"></a>21.1 21.1 生成器 VS 协程

> [返回目录](#chapter-one)

生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的。

```js
function* genDemo() {
  console.log("开始执行第一段");
  yield 'generator 2';

  console.log("开始执行第二段");
  yield 'generator 2';

  console.log("开始执行第三段");
  yield 'generator 2';

  console.log("执行结束");
  return 'generator 2';
}

console.log('main 0');
let gen = genDemo();

console.log(gen.next().value);
console.log('main 1');

console.log(gen.next().value);
console.log('main 2');

console.log(gen.next().value);
console.log('main 3');

console.log(gen.next().value);
console.log('main 4');
```

函数 `genDemo` 并不是一次执行完的，全局代码和 `genDemo` 函数交替执行。

协程是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务。

一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行。

同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。

正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

## <a name="chapter-twenty-two" id="chapter-twenty-two"></a>二十二 DOM

> [返回目录](#chapter-one)

### <a name="chapter-twenty-two-one" id="chapter-twenty-two-one"></a>22.1 什么是 DOM

> [返回目录](#chapter-one)

从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。

DOM 提供了对 HTML 文档结构化的表述。

在渲染引擎中，DOM 有三个层面的作用：

* 从页面的视角来看，DOM 是生成页面的基础数据结构。
* 从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。
* 从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。

### <a name="chapter-twenty-two-two" id="chapter-twenty-two-two"></a>22.2 如何生成 DOM

> [返回目录](#chapter-one)

在渲染引擎内部，有一个叫 HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。

HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。

1. 网络进程接收到响应头之后，会根据响应头中的 `content-type` 字段来判断文件的类型，比如 `content-type` 的值是 `text/html`，那么浏览器就会判断这是一个 HTML 类型的文件
2. 然后为该请求选择或者创建一个渲染进程
3. 渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据 “喂” 给 HTML 解析器。
4. 把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。

### <a name="chapter-twenty-two-three" id="chapter-twenty-two-three"></a>22.3 JavaScript 如何影响 DOM

> [返回目录](#chapter-one)

JavaScript 文件的下载过程会阻塞 DOM 解析，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。

如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 `async` 或 `defer` 来标记代码。

## <a name="chapter-twenty-three" id="chapter-twenty-three"></a>二十三 CSS 阻塞问题

> [返回目录](#chapter-one)

1. 当渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。
2. 碰到加载 CSS 文件的时候，发起 CSS 文件的下载
3. DOM 构建结束之后、CC 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。

和 DOM 一样，CSSOM 也具有两个作用，第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息。

## <a name="chapter-twenty-four" id="chapter-twenty-four"></a>二十四 其他

> [返回目录](#chapter-one)

后面没有进一步做笔记的：

* CSS 动画比 JavaScript 高效
* 页面性能
* 虚拟 DOM
* PWA：渐进式网页应用
* WebComponent：组件化开发
* HTTP/1
* HTTP/2
* HTTP/3
* 同源策略
* XSS
* CSRF
* 安全沙箱
* HTTPS

HTTP 演进史：

* **HTTP/0.9** 传输体积很小的文件，没有 HTTP 请求头和请求体，服务器也不返回头信息。
* **HTTP/1.0** 核心诉求是支持多种类型的文件下载。加入了请求头和响应头支持多种不同类型的数据。以及状态码、Cache 机制、用户代理等。
* **HTTP/1.1**
  * 改进了 1.0 版本每次 HTTP 通信都需要建立 TCP 连接、传输 HTTP 数据再断开 TCP 连接的尴尬局面，支持持续连接。只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持（默认开启）。
  * 如果 TCP 通道中某个请求因为某些原因没有及时返回，会阻塞后面所有请求（队头阻塞），所以 HTTP/1.1 通过管线化来解决队头阻塞的问题。
  * HTTP/1.0 每个域名绑定唯一 IP 地址，一个服务器只能支持一个域名。HTTP/1.1 请求头增加 Host 字段，表示当前域名地址，服务器可以根据不同的 Host 值做不同的处理。这样一台物理主机就可以绑定多个虚拟主机，每个虚拟主机都有自己单独的域名。
  * HTTP/1.0 需要在响应头设置完整的数据大小来接收数据，但是随着服务器端发展，很多页面动态生成，不知道传输数据的最终大小。HTTP/1.1 引入 Chunk transfer 机制来解决这个问题，服务器将数据分割成任意大小的数据块，每个数据块发送时附带上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志，从而支持了动态内容。
  * 客户端 Cookie、安全机制。
* **HTTP/2.0** 一个域名只使用一个 TCP 长连接和消除队头阻塞问题
  * 一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。HTTP/2.0 实现了一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。
  * 队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP/2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。
* **HTTP/3.0** QUIC 协议
  * 实现了类似 TCP 的流量控制、传输可靠性的功能。
  * 集成了 TLS 加密功能。
  * 实现了 HTTP/2 中的多路复用功能。
  * 实现了快速握手功能。

## <a name="chapter-twenty-five" id="chapter-twenty-five"></a>二十五 参考文献

> [返回目录](#chapter-one)

* [x] [极客时间 - 浏览器工作原理与实践](https://time.geekbang.org/column/intro/100033601)【阅读建议：11.5h】
* [x] [廖雪峰 - 进程和线程](https://www.liaoxuefeng.com/wiki/1016959663602400/1017627212385376)【阅读建议：10min】

---

> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">jsliang 的文档库</span> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/LiangJunrong/document-library" property="cc:attributionName" rel="cc:attributionURL">梁峻荣</a> 采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。<br />基于<a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/LiangJunrong/document-library" rel="dct:source">https://github.com/LiangJunrong/document-library</a>上的作品创作。<br />本许可协议授权之外的使用权限可以从 <a xmlns:cc="http://creativecommons.org/ns#" href="https://creativecommons.org/licenses/by-nc-sa/2.5/cn/" rel="cc:morePermissions">https://creativecommons.org/licenses/by-nc-sa/2.5/cn/</a> 处获得。