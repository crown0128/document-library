原型链
===

> Create by **jsliang** on **2020-09-17 15:50:00**  
> Recently revised in **2020-09-26 16:34:36**

<!-- 目录开始 -->
## <a name="chapter-one" id="chapter-one"></a>一 目录

**不折腾的前端，和咸鱼有什么区别**

| 目录 |
| --- |
| [一 目录](#chapter-one) |
| <a name="catalog-chapter-two" id="catalog-chapter-two"></a>[二 前言](#chapter-two) |
| <a name="catalog-chapter-three" id="catalog-chapter-three"></a>[三 题目](#chapter-three) |
| &emsp;[3.1 题目 1：选择题](#chapter-three-one) |
| &emsp;[3.2 题目 2：阐释原因](#chapter-three-two) |
<!-- 目录结束 -->

## <a name="chapter-two" id="chapter-two"></a>二 前言

> [返回目录](#chapter-one)

## 普通对象和函数对象

JavaScript 中，万物皆对象。

就好比同样为人，也区分普通人和天才。

对象也是有分类的，分为 **普通对象** 和 **函数对象**。

而 `Object` 和 `Function` 都是 JavaScript 自带的函数对象。

```js
function fun1() {};
const fun2 = function() {};
const fun3 = new Function();

const obj1 = {};
const obj2 = new Object();
const obj3 = new fun1();

console.log(typeof Object); // function 
console.log(typeof Function); // function  

console.log(typeof fun1); // function 
console.log(typeof fun2); // function 
console.log(typeof fun3); // function   

console.log(typeof obj1); // object 
console.log(typeof obj2); // object 
console.log(typeof obj3); // object
```

在上面代码中，`fun1`、`fun2`、`fun3` 都是函数对象，`obj1`、`obj2`、`obj3` 都是普通对象。

区分方法：凡是通过 `new Function()` 创建的都是函数对象，而 `f1`、`f2` 和 `Object`、`Function` 归根结底也是通过 `new Function` 创建的。

## 构造函数

* 什么是构造函数？

当任意一个普通函数用于创建一个类对象时，它就被称作构造函数，或构造器。

1. 默认函数首字母大写
2. 通过 `new` 调用一个函数
3. 构造函数返回的是一个对象

例如：

```js
function Person(name) {
  this.name = name;
}
const person = new Person('jsliang');
```

这里的 `Person` 就是构造函数。

要清楚构造函数具体，我们可以看一下 `new` 的实现机制：链接。

## 原型

在 JavaScript 中，每当定义一个对象的时候，对象中都会包含一些预定义的属性。

其中每个 **函数对象** 都有一个 `prototype` 属性，这个属性的指向被称为这个函数对象的 **原型**。

```js
function Person() {};
Person.prototype.name = 'jsliang';
Person.prototype.sayName = function() {
  console.log(this.name);
};

const person1 = new Person();
person1.sayName(); // jsliang

const person2 = new Person();
person2.sayName(); // jsliang

// 这两个实例对应的原型方法 sayName 都是一样的
console.log(person1.sayName === person2.sayName); // true
```

## 实例和 constructor

```js
function Person(name) {
  this.name = name;
}
const person = new Person('jsliang');
```

在上面代码中，构造函数是 `Person`，而 `person` 则是构造函数 `Person` 的 **实例对象**（后面简称实例）。

> 构造函数通过 `new` 出来的结果，叫做实例

每个实例都会有个隐藏属性 `constructor`。

构造函数和实例存在一个等式：

```js
person.constructor === Person; // true
```

所以得出一个结论：

* **实例的属性 `constructor` 指向构造函数**

同时，这个函数的原型的 `constructor` 会指向这个函数：

```js
Person.prototype.constructor === Person; // true
```

## __proto__

每个 JavaScript 对象（普通对象和函数对象）都具有一个属性 `__proto__`，这个属性会指向该对象的原型。

看代码：

```js
function Person() {};
const person = new Person();

console.log(person.__proto__ === Person.prototype); // true
```

## 小结

通过上面的内容我们可以知道一些知识点。

定义：

1. 一般定义大写字母开头的函数叫构造函数
2. `new` 一下构造函数出来的结果叫实例对象（简称实例）
3. 构造函数通过 `prototype` 绑定的内容叫原型

等式：

1. 实例的属性 `constructor` 指向构造函数
2. 对象的 `__proto__` 指向该对象的原型
3. 函数的原型的 `constructor` 会指向这个函数

具体代码如下：

```js
function Person() {};
const person = new Person();

// 实例的构造函数属性 constructor 指向构造函数
console.log(person.constructor === Person); // true

// 对象的 __proto__ 指向该对象的原型
console.log(person.__proto__ === Person.prototype); // true

// 函数的原型的 constructor 会指向这个函数
console.log(Person.prototype.constructor === Person); // true
```

## Object 和 Function 的原型指向

```js
function Person() {};
const person = new Person();
```

在上面代码中，我们看到实例 `person` 是 `new` 构造函数 `Person` 出来的。

那么，`Person` 又是怎么来的呢？

```js
const Person = new Function();
// 相当于 function Person() {};
// 或者相当于 const Person = function() {};
console.log(Person.__proto__ === Function.prototype); // true
```

可以看到 `Person` 相当于 `new Function` 出来的，即：

```js
const Person = new Function();
const person = new Person();

console.log(person.__proto__ === Person.prototype); // true
console.log(Person.__proto__ === Function.prototype); // true
```

那么，下面这个呢？

```js
const obj = new Object();
// 相当于 obj = {};
console.log(obj.__proto__ === Object.prototype); // true
```

## 原型链

```js
function Person() {};
Person.prototype.name = 'jsliang2';
Object.prototype.name = 'jsliang3';

const person = new Person();

// 当前展示
console.log(person.name); // jsliang2

// 往实例添加属性
person.name = 'jsliang1';
console.log(person.name); // jsliang1

// 删除实例属性
delete person.name;
console.log(person.name); // jsliang2

// 删除构造函数原型
delete Person.prototype.name;
console.log(person.name); // jsliang3

// 删除 Object 原型
delete Object.prototype.name;
console.log(person.name); // undefined

console.log(person.__proto__ === Person.prototype); // true
console.log(person.__proto__.__proto__ === Object.prototype); // true
```

原型链：如果一个实例对象不存在某个属性，那么 JavaScript 就会往该构造函数的原型上找；如果该构造函数的原型没找到，那么会继续往 `Object` 的原型上找；如果 `Object` 的原型还没有，那就返回 `undefined`。

## <a name="chapter-three" id="chapter-three"></a>三 题目

> [返回目录](#chapter-one)

### <a name="chapter-three-one" id="chapter-three-one"></a>3.1 题目 1：选择题

> [返回目录](#chapter-one)


```js
var F = function() {};

Object.prototype.a = function() {};
Function.prototype.b = function() {};

var f = new F();
```

请选择：

* A：`f` 能取到 `a`，但取不到 `b`。
* B：`f` 能取到 `a`、`b`。
* C：`F` 能取到 `b`，不能取到 `a`。
* D：`F` 能取到 `a`，不能取到 `b`。

---

答案：A

解析：

* `F.a = function`
* `F.b = function`
* `f.a = function`
* `f.b = undefined`

首先，函数 `F` 通过原型链，可以找到

```js
Object.prototype.a = function() {};
Function.prototype.b = function() {};
```

这两个绑定的 `a` 和 `b`。

但是 `f = new F()` 出来的是一个 Object，而不是 Function。

所以 `f` 能找到 `a`，但是找不到 `b`。

### <a name="chapter-three-two" id="chapter-three-two"></a>3.2 题目 2：阐释原因

> [返回目录](#chapter-one)

```js
Function.prototype.a = 'a';
Object.prototype.b = 'b';
function Person();
var p = new Person();

console.log(p.a); // undefined
console.log(p.b); // b
```

请讲述下原因？

---

答案：

`Person` 函数是 `Function` 对象的一个实例，所以可以访问 `Function` 和 `Object` 原型链上的内容。

而 `new Person` 返回的是一个对象，只能访问挂载到 `Object` 原型链上的内容。

所以只有 `p.b`。

---

> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">jsliang 的文档库</span> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/LiangJunrong/document-library" property="cc:attributionName" rel="cc:attributionURL">梁峻荣</a> 采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。<br />基于<a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/LiangJunrong/document-library" rel="dct:source">https://github.com/LiangJunrong/document-library</a>上的作品创作。<br />本许可协议授权之外的使用权限可以从 <a xmlns:cc="http://creativecommons.org/ns#" href="https://creativecommons.org/licenses/by-nc-sa/2.5/cn/" rel="cc:morePermissions">https://creativecommons.org/licenses/by-nc-sa/2.5/cn/</a> 处获得。